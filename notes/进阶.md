> # **总纲**

- 基础
  - ECMASCRIPT
  - JAVASCRIPT（尚未整理完全）
- 进阶
  - FLOW.js
  - TYPESCRIPT

# ECMASCRIPT

## 简介

- ECMAScript是由网景的[布兰登·艾克](https://baike.baidu.com/item/布兰登·艾克/19277417)开发的一种脚本语言的标准化规范；最初命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript。1995年12月，升阳与网景联合发表了JavaScript。1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。ECMA Script是ECMA-262标准化的脚本语言的名称。尽管JavaScript和JScript与ECMAScript兼容，但包含超出ECMA Script的功能。
- ECMAScript是一种可以在宿主环境中执行计算并能操作可计算对象的基于对象的[程序设计语言](https://baike.baidu.com/item/程序设计语言/2317999)。ECMAScript最先被设计成一种Web脚本语言，用来支持Web页面的动态表现以及为基于Web的客户机—服务器架构提供服务器端的计算能力。但作为一种脚本语言， ECMAScript具备同其他脚本语言一样的性质，即“用来操纵、定制一个已存在系统所提供的功能，以及对其进行自动化”。 [1]

总结

是一种脚本语言的设计规范

# JAVASCRIPT

## 1.简介

JavaScript（简称“JS”） 是一种具有[函数](https://baike.baidu.com/item/函数/301912)优先的[轻量级](https://baike.baidu.com/item/轻量级/22359343)，解释型或即时编译型的高级[编程语言](https://baike.baidu.com/item/编程语言/9845131)。虽然它是作为开发Web页面的[脚本语言](https://baike.baidu.com/item/脚本语言/1379708)而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型[编程](https://baike.baidu.com/item/编程/139828)、多范式的动态脚本语言，并且支持[面向对象](https://baike.baidu.com/item/面向对象/2262089)、命令式和声明式（如[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)）风格。 [1]

**js的三大组成部分:**

- **ECMAScript:**js语法的基础,定义了js的基本语法
- **BOM:**提供了操作浏览器这个软件的一些方法
- **DOM:**提供了操作标签元素的一些方法

总结

可运行在服务端（node）和web端的脚本语言

## 2.标识符及数据类型

### 2.1 标识符

- **标识符可以含有字母，数字，_,_$等;**

- **标识符不能以数字开头；**

- **标识符不能是JS中的关键字或保留字；**

- **标识符一般采用驼峰命名法：首字母小写，每个单词的开头字母大写，其余字母小写**

- **标识符就是JS中的变量(ES6有了常量的概念),变量使用前必须要先定义**

- **有3种命名符来命名表示符**

  - var，ES6之前用的命名符,但是作用域是函数作用域,并且支持在当前作用域中进行重复命名,有很大隐患

  - let，ES6新增命名变量方法,作用域和其他语言的作用域一样都在块级作用域中,ES6推荐使用

  - const,ES6新增的常量命名法,用这个命名符来命名的标识符为常量,只能用不能修改值,修改值就会报错,推荐在某一个量只用一次的时候用这个命名符

    **注意:**用const声明的常量不是不能赋值,而是不能通过=进行二次赋值,在不改变原来常量结构的情况下可以

    改变这个常量的属性值

### 2.2 数据类型

#### 2.2.1 六大数据类型

**注：ES6新增为7种,多了一种symbol符号的数据类型用作私有变量的使用**

**JS的数据类型分为5大基本数据类型和一个复杂数据类型object**

- **字符串string**

  - 字符串可以用""(单引号)或者''(双引号)或者``(反引号:ES6支持)

  - 单双引号没有区别，但是不要混合用

  - 在字符串中要使用js的变量有两种写法

    - ES5支持的用字符串拼接的方法

    - ES6中支持的必须用``(反引号)才支持的${变量名}的写法

      用``写的字符串又被称作**模板字符串**,能够更轻松的在字符串中插入变量

  - 当需要用一些特殊符号表示时，可以在特殊符号前加一个\和转义字符的用法基本相似比如用\ "表示"

    \ \ 表示 \

- **数值number**

  - JS中可以表示数值的最大值Number.MAX_VALUE

  - 如果超过了最大值,就会返回一个Infinity意为无穷,此时这个无穷是正无穷,而-Infinity为负无穷 

  - NaN也是一个特殊的数字，意为not a number,可以用很多方法得到这个数

    比如:两个字符串相乘返回NaN

  - Number.MIN_VALUE为最小值,但是是0以上的最小值,并不是负数

  - JS中的整数运算可以基本保证精确，浮点运算得到的结果不够精确

- **布尔值boolean**

  该类型只有两个值:true(正确),false(错误)

- **null**

  null的值就是null，专门用来表示空对象

- **undefined**

  - undefined的类型只有一个,就是undefined,当声明一个变量,却不给它赋值时,它的值就是undefined

  - 使用typeof来检验undefined也会返回undefined

- **object**

  这个类型的值最多,应为所有事物都可以看做是对象

- **symbol**

  唯一标识

- BigInt

  大整数，草案，还没出



#### 2.2.2 强制类型转换

- **将其他数据类型转换为String**

  **1.调用被转换数据类型的toString()方法**

  **注:**

  **1.**该方法不能影响原来变量，而是有一个返回值

   **2.**null和undefined这两个值没有toString()方法，如果调用会报错

  ```js
  var a=123;
  a=a.toString();
  ```

  

  **原型prototype后说明toString()方法**

  当我们直接在页面中打印一个对象时，实际上是输出对象的toString()方法的返回值,所以直接打印一个对象和打印这个对象用toString后的值是一样的,如果我们希望在输出对象时不输出[Object Object],可以为对象的原型添加一个toString()方法来改变输出的值,所以可以在里面写入自己想要的提示(直接只写return就可以),如果用的构造函数的方法最好加上this

  

  **2.调用String()函数**

  使用String()函数做强制转换时，实际对于Number和Boolen等调用toString()方法,但是对于null和undefined会直接转换为"null"和"undefined"

  ```js
  var a=null; 
  a=String(a);
  ```

  

- **将其他数据类型转换Number**

  **1.使用Number()函数**

  - **字符串转换为数字**	

    - 如果是纯数字字符串，则直接转化为数字	

    - 如果字符串中有非数字字符，则返回NaN,只要有就会

    - 如果是一个空串或者一个全是空格的字符串则会返回0

      **如：**

      ```js
      var a="123";
      a=Number(a);//会返回123
      var b="abc"
      b=Number(b);//会返回NaN
      ```

  - **布尔值转换为数字**

    true为1,false为0

  - **null转化为数字为0**  

  - **undefined转化为数字为NaN** 	

  

  **2.使用parseInt()和parseFloat()函数**

  **注:该方法在ES6已经移植到Number对象下,作为Number的方法使用,与全局时的行为一样**

  该方法可以取出字符串的有效数字内容,从头开始取,parseInt是只要遇到非数字就会立刻结束,而parseFloat允许接收到一个小数点,遇到其他的非数字或者第二个小数点时会停止,想要把a="123px"中的123取出来的时候用这种方法才能达到效果​

  **将一个小数转换为整数可以对它使用parseInt()函数**	

  **注意:**

  - 这个方法最好专门对字符串用 如果对非String用回先把它转换为String再进行操作

    **如：**如果是布尔值等会转换为"true"在这个字符串再进行转换，这样会返回NaN

  - 这个方法现在是可以直接作为window的方法调用,所以可以事件省略,但是ES6规定必须要通过Number内建函数来调用,所以最好还是通过Number对象调用

    ```js
    var a="1.23px"
    console.log(Number.parseFloat(a));//1.23
    ```

    

  **对数值及parseInt函数实现进制转换的补充:**

  - 在JS表达16进制数字，需要以0(零)x开头 。如:a=0x10,输出的时候得到a=16

    任何用上方这种语法写的数字输出的时候都会转换为16进制的数字

  - 需要表示8进制的数字需要以0开头,用法如上

  - 2进制开头用0b表示(但不是所有浏览器都支持)

  - 实际上parseInt这个函数可以接收两个参数,第一个是要转换的字符串,第二个是需要转换的进制

    **注意:**把 a="070"转化为整数,a=parseInt(a)再输出有些浏览器会当成8进制，有些浏览器会省略掉前面的0直接变为10进制，如果想所有的浏览器一样，可以a=parseInt(a,10)，添加第二个参数，来指定数字的进制

  

- **将其他的数据类型转换为布尔值**

  **使用Boolean()函数**

  - 数字转换为布尔值，除了0和NaN都是true

  - 字符串转换为布尔值，除了空串都是true

  - null转换为布尔值，false

  - undefined转换为布尔值，false

  - 对象object也会转换为true

  **六大假值:0  NaN  undefined  null  ""  false**

#### 2.2.3SYMBOL

##### 用法

Symbol其实是es6新增加的一种原始数据类型，symbol的引入就是未了保存私有变量名（key），当引入一个别人创建的对象时，如果不清楚这个对象有哪些属性，但又想要为这个对象添加属性时，很容易出现属性名冲突的问题，因为这个问题，es特地引入了Symbol这个特殊的标识

##### 创建

```
//Symbol类型的值不能字面量创建,而是通过Symbol()函数来创建
var symbol=Symbol('我只是为了让开发者理解，不代表实际数据')
console.log(typeof sym);//symbol
let a1=Symbol(1)
let b1=Symbol(1)
console.log(a1===b1) //false   即使内存地址相同也不能取到同一个值，也就是说这个值从创建时起就是唯一的，只能通过引用地址去获取
```

**注意:**

- **Symbo()函数不是一个构造函数,不能用new操作符。**所以Symbol类型的值也不是一个对象,不能添加任何属性,它只是一个类似于字符串的数据类型,如果在声明一个Symbol类型的值前面加上new就会报错

- **Symbol()类型的值不能够进行计算,**包括Symbol类型的任意数据类型都不可以,一旦进行计算就会报错

- **Symbol类型的值可以转换为字符串和布尔值,但是不能转换为数值,否则会报错,**并且转换成布尔值时永远都是true,不管内部是什么参数

  ```js
  var sym=Symbol();
  var sym1=Symbol(false);
  
  console.log(String(sym));"Symbol()"
  console.log(String(sym1));"Symbol(false)"
  console.log(Boolean(sym));//true
  console.log(Boolean(sym1));//true
  ```

- **因为是通过一个变量来接收的Symbol值,所以在使用Symbol值作为属性名时,获取对应的属性不能用点操作符,**如果用点操作符实际上时获取一个字符串,而不是Symbol值。同时**在对象内部用该变量创建属性名时也要要[]括起来**,否则该属性名依然只是一个字符串,而不是用的Symbol变量

  ```js
  //Symbol值作为属性名时有多种用法
  var name=Symbol();
  var a={};
  
  //第一种
  a[name]="孙悟空";
  
  //第二种
  a={
      [name]:"孙悟空";
  }
  
  //第三种
  Object.defineProperty(a,name,{value:"孙悟空"});//这里的name是变量
  
  //输出
  console.log(a.name);//undefined
  console.log(a[name]);//孙悟空
  console.log(a["name"]);//undefined
  ```

- **unIterator不可迭代，当遍历对象的属性值时,无法用for...in和for...of语句遍历到Symbol值的属性,也无法通过Object.keys() 、Object.getOwnPropertyNames()等函数来获取。**但是可以通过使用Object.getOwnPropertySymbols()函数获取一个对象上的Symbol属性名,也可以使用Reflect.ownKeys()函数返回所有类型的属性名,包括常规的属性名和Symbol属性名

  ```js
  var sym1=Symbol("sym1");
  var sym2=Symbol("sym2");
  var a={
      [sym1]:"sym1",
      [sym2]:"sym2",
      hello:"hello"
  }
  console.log(Object.getOwnPropertyNames(a));//[Symbol(sym1),Symbol(sym2)]
  console.log(Object.keys(a));//["hello",Symbol(sym1),Symbol(sym2)]
  ```

  **注:**正因为Symbol值作为对象的属性值无法被遍历到的这一特性,可以对对象定义一些非私有的但是又希望只有内部可用的方法

##### 2.Symbo()的参数

- **字符串作参数**

  **在创建一个symbol类型的值的时候,如果不传入任何参数,在调用变量的时候不好进行去区分,打印的值全都是`Symbol()`,传入一个字符串作为参数,可以对Symbol的值进行描述,方便我们区分不同的Symbo值**

  ```js
  var sym1=Symbol("sym1");
  var sym2=Symbol("sym2");
  var sym3=Symbol("sym1");
  console.log(sym1);//Symbol(sym1)
  console.log(sym2);//Symbol(sym2)
  console.log(sym1===sym3);//false
  
  /*
  	1.给Symbol()函数传入参数后可以在控制台输出的时候区分到底是哪一个值
  	2.Symbol()函数中传入的参数只是用来对当前的Symbol变量的描述,而没有其他意思,相同参数的
        Symbol()函数的返回值是不同的
  */
  ```

- **其他类型作参数**

  **当用其它类型的值作为参数传入到Symbol()函数中时,会自动将该参数转换为字符串类型,但是注意当传入的值为undefined的时候此时Symbol()函数中相当于没有传入参数,所以返回的依然是Symbol()**



##### 3.Symbol.for与Symbol.keyFor函数

- **Symbol.for()也函数可以用来生成Symbol值,但该函数有一个特殊的用处,该函数创建的Symbol值可以通过内部的参数重复使用一个Symbol值**

  Symbol.for()函数接收一个字符串作为参数,先搜索有没有以该参数为名称的Symbol值,**如果有直接返回这个Symbol值,如果没有就新建一个以给字符串为名称的Symbol值**

  ```js
  var sym=Symbol("sym1");
  var sym1=Symbol.for("sym1");
  var sym2=Symbol.for("sym2");
  var sym3=Symbol.for("sym1");
  
  console.log(sym===sym1);//fasle,因为用Symbol()创建的Symbol值没有计入Symbol值的登记中
  console.log(sym1===sym2);//false,因为参数标识不一样,重新创建了Symbol值
  console.log(sym1===sym3);//true,参数标识一样,相当于先前是sym3=sym1
  ```

- **Symbol.keyFor()函数用来查找一个Symbol值的登记信息(这个登记信息就是创建Symbol值时在函数中传入的参数)**,因为Symbol()函数创建的Symbol值没有登记机制,所以会返回undefined,而Symbol.for()函数会将生成的Symbol值的信息记录在全局环境中,所以Symbol.keyFor()函数可以查找到Symbol.for()函数创建的Symbol值，**该函数的返回值是字符串**

  ```js
  var sym1=Symbol.for("sym1");
  console.log(Symbol.keyFor(sym1));//"sym1"
  console.log(Symbol.keyFor(sym1)==="sym1");//true
  ```

### 2.3 解构赋值

**解构赋值为ES6的语法,ES6中,允许按照一定模式,从数数组和对象中提取值,对变量进行赋值,这种行为被称为解构**

```
var [a,b,c,d]=[1,2,3]  
//   1,2,3,undefined
var {x:x,y:y,z:z} = {x: 1, y: 2, z: 3};
console.log(x, y, z);//1,2,3
/*
注意:
1.当右边为对象时,对象中的属性也是模式的一部分,所以必须也要在左边写上相同的属性名
2.当左边的属性名和属性值的变量时相同时,可以只写属性值,这个属性值也是要用的变量名
*/
```

## 3.运算符

### 3.1 js功能运算符

- typeof，鉴定数据类型


```js
typeof ‘12’:  string
typeof true:  boolean
typeof 12:  number
typeof null:  object
typeof undefined:  undefined
typeof {}:  object
typeof []:  object
typeof function:  function
```

**in,用于检查一个对象中是否含有指定的属性,如果有则返回true,没有则返回false**

```js
var obj=new Object();
console.log("test2" in obj); //这里显示false,因为obj中没有这个属性
							 //属性名实际上是字符串，所以要加""
```

**instanceof,用于确定一个对象是否在另一个对象的原型链上,也就是一个对象是否属于另一个类对象的实例**

```js
//可以使用instanceof可以检验一个对象是否是一个类的实例

function Person(name){
	this.name=name
}		
  var per= new Person("孙悟空");
  console.log(per instanceof Person);//如果per是Person类的实例返回true，否则返回false
  
  console.log(per instanceof Object);
//所有的对象都是Object的后代，所有任何对象和Object与instanceof检验都会返回true
```

### 3.2 算数运算符

**JS中的算术运算符和其他语言一样有+ - * / %等**

注意：

- 在算数运算符进行运算时如果两边有非number类型的，js会先为其进行隐式类型最欢，再进行运算

+的特殊用法

**+的特殊用法:**如果对两个字符串进行加法运算，则会做拼串并返回,任何值和字符串做加法运算，都会先转换为字

符串，然后再拼串

**注:**可以利用+的特殊性这一特点将任意数据类型转换为String，将任意数据类型+一个""空串转换为String，实质上也是调用的String函数

```js
var result=1+"2"+3//结果会是字符串123

var result=1++"2"+3//结果会是数字6，++"2"实际是是先计算的+"2"把字符2转换为数字2
```

**自增自减**

let value=++a先运算再赋值；   a++,先赋值再运算

##### 项目实际踩雷

```js
console.log(0.07*100);//7.000000000000001
```

<a href="https://segmentfault.com/a/1190000012175422?utm_source=tag-newest">js浮点数</a>

1. 计算机内部如何表示整数

这里以十进制数13来展示“按位计数法”如何表示整数：

| 十进制值 | 进制 | 按位格式 | 描述                                          |
| -------- | :--- | -------- | --------------------------------------------- |
| 13       | 10   | 13       | 1x10^1 + 3x10^0 = 10 + 3                      |
| 13       | 2    | 1101     | 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1 |

2. 计算机内部如何表示小数

再看小数怎么用按位计数法表示，以十进制数0.625为例：

| 十进制值 | 进制 | 按位格式 | 描述                                             |
| -------- | ---- | -------- | ------------------------------------------------ |
| 0.625    | 10   | 0.625    | 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005 |
| 0.625    | 2    | 0.101    | 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8        |

### 3.6 运算符优先级

### 3.3 逻辑运算符

**逻辑运算符有:与或非 && || !**

- !(非运算符)对一个数进行非运算，如果不是布尔值会被转换为布尔值(这种运算方法只适合JS)  

  **可以利用这一特性为任意数据类型取两次反将其转换为布尔值，原理与Boolean()一样**

  ```js
  var a="hello"
  a=!!a//true
  ```

- &&(与运算符)如果第一个值就是false就不会去看第二个值，第一个值是true会检查第二个值

- ||(或运算符)如果第一个值是true就不会检查第二个值,直接返回第一个值

  ```js
  true||alert("s")//不会执行弹窗
  false||alert("s")//执行弹窗
  ```

对于非布尔值进行运算，会先转换为布尔值，再进行运算，并返回原值，不会返回布尔值

**总结:**

&&运算如果第一个值为true则直接返回第一个值，如果第一个值是false，则直接返回第一个值

||运算如果第一个值为true则直接返回第一个值，如果第一个值是false则直接返回第二个值

### 3.4 关系运算符

通过关系运算符比较两个值之间的大小关系,关系成立则返回true,关系不成立则返回false

**关系运算符有:\>   <    >=    <= 等**

**注意:**

- 关系运算符比较的一般都是number类型的值,如果不是number类型会转换为number类型

- 任何值和NaN做比较都会返回false

- 如果符合两测的值都是字符串时(如果有一方不是字符串就是全部转换为number类型再比较)，不会将其转换

  为数字进行比较，而会分别比较Unicode编码(UTF-8)，和C语言中的strcmp一样。所以，在比较两个字符串型

  的数字时，一定要转型，至少在其中一个前面加上+

### 3.5相等运算符

相等运算符有 == ===两种

- **==两边会进行隐式类型转换再做比较，建议不要使用，尤其是现在类型检测极为重要的年代**

- ```js
  '2'==2 //true
  ```

- **当===(全等)和!==(不全等)两边类型不同时不会进行自动类型转换,直接返回false**

```js
console.log('NaN ===NaN: ', NaN ===NaN);
console.log('NaN ===NaN: ', Number.isNaN(NaN));
```

注意：

NaN无法通过三等运算做判断，需使用Number.isNaN(),调用该方法时不会进行强制类型转换

**注:在ES6中引入了一个Object.is()方法作为判断,该方法能对NaN进行相等判断**

Object.is()方法可以接收两个参数,这两个参数为进行比较的两个值，该函数不会进行强制类型转换,相当于===

**与全等(===)的区别**

- +0不能用-0
- NaN等于自身

```js
console.log(Object.is(NaN,NaN));//true
console.log(Object.is(+0,-0));//false
console.log(Object.is(123,"abc"));//false
console.log(Object.is(123,"123"));//false
```

### 

**js中的运算符优先级是一套规则,该规则在计算表达式时控制运算符执行的顺序,具有较高优先级的运算符先于较低优先级的运算符执行**

**下表按从最高到最低的优先级列出js运算符,具有相同优先级的运算符按从左至右的顺序求值**

| 运算符                             | 描述                                         |
| ---------------------------------- | -------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| \|                                 | 按位或                                       |
| &&                                 | 逻辑与                                       |
| \|\|                               | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |

转自https://www.cnblogs.com/yy-hh/p/4624792.html

## 4.逻辑语句

### 4.1 if else

#### 4.1.1 if

语句对一个属性或者表达式进行判断,里面的数或表达式最后会转换为布尔值，如果为真才执行执行if语句里面的

代码

#### 4.1.1 if

```js
if(true){
    console.log(1);
}
//只判断是否为真
```



#### 4.1.2 if...else

```js
if(true){
    console.log(1);
}
else{
    consle.log(2);
}
//判断时否为真,如果为真执行上面的代码,如果为假执行下面的代码
```



#### 4.1.3 if....else if....else

```js
var a=1;
if(a===1){
    console.log(1);
}
else if(a===2){
	console.log(2);    
}
else{
    console,log(3);
}
//从上到下一次进行判断,如果第一次判断为真则执行第一个判断里面的代码,如果第一次为假第二次为真则执行第二个	判断里的代码,如果都为假则执行第三个判断里的代码

  //在这里else if可以写无数个,因为这个其实还是按照if...else的写法来写的
```

### 4.2 switch语句

```js
switch(x)
{
    case 1：；
    break;
    case 2: ;
    break;
  	default:
}
//括号里的字母依次与下面做全等(===)比较
```

```js
可以在case里面用数字或者字符一起用，只是做全等比较而已，比如和以x="abc"
switch(x)
{
	case 1:;
    break;
	case 2:;
	break;
	case "abc":;
	break;
	default:
}
```

**注意:**

- **JS里面的switch中的case可以接受一个表达式**，因为swich语句在其他语句时case里面只能是数字或者字符

```js
var score=80;
switch(true){
case score>=60：
case score>=50:
}
```

-  switch语句中每一个case后面需要加上break来表示跳出选择,不然就会一直往下面运行case直到遇到break或将里面的选项全部运行完

### 嵌套if的情况下最好用switch，避免嵌套过深

## 5.循环语句

#### **5.1 while和do...while语句**

while 和 do...while都是循环语句，两者唯一的不同在于do while会先执行在判断

```js
var i=0;
while(i>5){
    console.log(i);
}

do{
	console.log(i);
}while(i>5)
    
//两个语句循环功能类似，不同的是while是先判断后执行，do...while是先执行后判断
//所以在进行判断的时候while可以一次都不执行,而do...while至少会进行一次

```

#### 5.2 for循环语句

```js
/*
	foo(单次表达式;条件表达式；动作){
	 中间循环体
	}
    for(var i=0;i<5;i++){
      console.log(i);
    }	
    //单次表达式只会在开始的时候进行一次,后面将不会进行,可以在单次表达式声明变量,也可以在前面先声明变量
//执行末尾循环体后将再次进行条件判断，若条件还成立，则继续重复上述循环，当条件不成立时则跳出当下for循环

*/
```

注意：

- 表达式都可以省略，但是分号必须留着，因为可以代表空语句

- break和continue都可以提前终止循环语句

- 在用for循环循环一个数组的长度时,如果先在外边将数组的长度赋值,会提升程序性能

  ```js
  var arr=[1,2,3,4,5];
  for(let i=0,len=arr.length;i<len;i++){
      console.log(i);
  }
  ```

#### 5.3 性能测试

用console.time()测试程序性能

```js
 /*
 console.time("计时器的名字")可以用来开启计时器，它需要一个字符串作为参数，这个字符串作为计时器的标识
 然后在需要测试的代码后面加console.timeEnd("计时器的名字")停止一个计时器
*/
console.time("test");
for(var i=0;i<5;i++){
    console.log(i);
}
console.timeEnd("test");
// 会在控制台中显示之间一共用了多长时间
```

## 6.普通对象

### 6.1对象的分类

JS中的数据类型有String、Number、Boolean、Null、Undefined、Symbol、Object前六个为基本数据类型，Object为内存地址引用

对象的分类

- 内建对象
  - 由es标准中定义的对象，在es规范的任何语言中都可以使用，例如Math String Number Object Function Boolean等
- 宿主对象
  - 由js的运行环境提供的对象，例如浏览器的Window、node的Global
- 自定义对象
  - 开发人员自己创建的对象

### 6.2创建对象

#### 6.2.1构造函数创建对象

使用new关键字调用的函数，是构造函数constructor，由new创建的对象均称为实例化对象

```js
var obj=new Object()
console.log(typeof obj)//使用typeof检查一个对象时，会返回object
console.log(obj)//这里obj是一个空的对象,之间打印这个对象会返回Oject{}
```

- **属性**

在对象中保存的值称为属性,向对象中添加属性,语法:对象.属性名=属性值;或对象["属性名"]=属性值;

```js
var obj=new Object();
obj.name="孙悟空";
obj.gender="男";
obj.age=18;
console.log(obj)//在这里obj中有值会打印出Object{name:"孙悟空",gender:"男",age:18}
```



- **读取对象中的属性**

**语法:对象.属性名或对象["属性名"]**

**注:**如果读取对象中没有的属性,不会报错而是会返回undefined



- **修改对象的属性值**

**语法:对象.属性名=新值或对象["属性名"]=新值**



- **删除对象的属性**

**语法:delete 对象.属性名或delete 对象["属性名"]**

**注:**删除后的属性不再存在于整个对象中,如果再次读取会返回undefined



- **验证对象中是否有该属性**

**语法:"属性名" in 对象**

**注:**属性名实质上时字符串,所以要加引号



- **属性名**

- **对象的属性名不强制要求遵守标识符的规范,但是使用时尽量按照标识符的规范去做**

- **如果在创建属性名时用的是.或者[]方法中的一个,在调用和修改删除时也要用同样的方式调用**

- **要使用特殊的属性名，不能使用.的方式，需要用   对象["属性名"]=属性值的方式**

  使用[]这种形式去操作属性更加的灵活，在**[]中甚至可以直接传递一个变量**,这样就能通过变量名来改变属性名,

  而**.只能跟去掉了""的字符串.的方式,不能使用变量**

  ```js
  var obj=new Object();
  var x="name";
  
  obj["name"]="孙悟空";
  obj["gender"]="男";
  
  console.log(obj[x]);//打印结果为孙悟空
  x="gender";
  console.log(obj[x]);//打印结果为男
  ```

  **注意:**

  - 如果[]中是一个变量就不要加引号,否则会认为是一个字符串
  - []里面除了字符串必须加引号，其他的可以不加引号，和基本数据类型相似



- **属性值**

JS对象的属性值,可以是任意的数据类型,包括对象

```js
var obj=new Object();
obj.test=obj2;
obj2=new Object();
Obj2.name="猪八戒"；

console.log(obj.test);//打印出obj2对象
console.log(obj.test.name);//打印出猪八戒
//由此可以说明对象的属性值可以是以对象来构成无限嵌套关系
```



- **枚举对象中的属性**

  for…in语句与for...of语句能够枚举对象中的属性，对象中有几个属性，循环体就会执行几次

  **注:**

  - for...of语句只能遍历数组,不能遍历JSON对象
  - for...in的性能很差,因为会遍历对象的原型对象

  ```js
  /*
  语法:
  for(var 变量 in/of 对象）{
  }
  */
  var obj={name:"孙悟空",gender:"男",age:18};
  for(var i in obj){
  	console.log(obj[i]);//打印出属性值
  }
  /*
  for…in语句
  每次执行时，会将对象中的属性名赋值给变量
  可以利用console.log(n);来获取属性值，n取得的属性值都会转化为字符串的形式,和前面的查找一个属性是否在字符串里面用in的情况不同
  */
  
  for(var i of obj){
  	console.log(i);//打印出属性值
  }
  /*
  for...of语句
  每次执行时,会将数组中的值赋值给变量，和for...in语句有所差别
  */
  ```

  

#### 6.2.2使用Oject.create创建的对象

```js
var crOb = Object.create({a:312321}, {
    foo: {
        writable: true,
        configurable: true,
        value: 'hellow create'
    },
    bar: {
        configurable: false,
        get: function () { return 10 },
        set: function (value) {
            console.log("Setting `crOb.bar` to", value)
        }
    }
})
console.log(crOb)
```

第一个参数为对象，对象为函数调用之后返回新对象的原型对象，第二个参数为对象本身的实例方法（默认不能修改,不能枚举）

```jsx
//创建一个可写的,可枚举的,可配置的属性p
obj2 = Object.create({}, {
  p: {
    value: 2,       // 属性值
    writable: true,     //  是否可以重写值
    enumerable: true,   //是否可枚举
    configurable: true  //是否可以修改以上几项配置
  }
});

obj2.p = 3;
console.log(obj2.p)     // 3
```

#### 6.2.2 对象字面量创建对象

**语法:{属性名:属性值,属性名:属性值....}**

```js
var obj={name:"孙悟空",gender:"男",age:18};
```

**注意:**

- 属性名和属性值之间的=要变成:

- 对象字面量的属性名加引号也可以不加，建议不加。但是如果使用一些特殊非法的名字，必须加引号，汉字也

  可以使用，对象字面量里面也可以嵌套使用对象字面量

**对象字面量创建对象的简化操作**

- 在创建函数的时候可以省略`:function`,直接用函数名
- 可以使用[]对属性名进行操作

```js
var obj={
    ["a"+"b"]:123,
    
    /*
    say:function(){
    	alert("hello");
    }
    */
    //方法的简写
    say(){
        alert("hello");
    }
}
```

### 6.3 JSON

**JSON全称为JavaScript Object Notation(javaScript对象表示法)**,JS中的对象只有JS才能够解析并识别,其它语言都不能识别,所以如果需要做数据传输,就需要一个所有语言都能够识别的通用数据类型

**JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互**,JSON和JS中对象的格式一致，只不过JSON字符串中的属性名和属性值必须用双引号括起来,除此之外内部结构的语法和JS中的语法一致

#### 6.3.1 JSON分类

- 对象{}
- 数组[]

 **注意:**无论是对象还是数组都必须使用字面量形式的,并且在最外层都需要用引号包裹让整体成为字符串



#### 6.3.2 属性值

**在JSON中的属性值只允许以下六种**

- 字符串
- 数值
- 布尔值
- null
- 对象
- 数组

**注:**undefined,symbol值和函数都不能作为属性值,对象形式如果有这三种类型的值会在转换为JSON的时候被过滤掉,数组形式如果有会被转换为null传入JSON中



#### 6.3.3 JSON与对象的转换

JS为我们提供了一个工具类对象JSON,这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

- **JSON-->JS对象**

  通过JSON.parse()函数可以将以JSON字符串转换为JS对象，该函数需要一个JSON字符串作为参数，会将JSON字符串转换为JS对象并返回

  ```js
  var json='{"name":"孙悟空","age":"18"}';
  var obj=JSON.parse(json);
  console.log(obj.name);//"孙悟空"
  ```

- **JS对象-->JSON**

  通过JSON.stringify()函数可以将一个JS对象转换为JSON字符串,该函数需要一个JS对象作为参数，会返回一个JSON字符串

  ```js
  var json={name:"孙悟空",age:"18"};
  var json=JSON.stringify(obj);
  console,log(json);//'{"name":"孙悟空","age":"18"}'
  ```

  **确认一个对象是否为空对象**

  ```js
  var obj={};
  var str=JSON.stringify(obj).replace(/\s|\r\n/g,"");
  if(str.length===2){
  	console.log("这是一个空对象")
  }
  ```

  

**注意:**JSON这个类对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错

## 7.数组

**数组也是一个对象**,它和普通对象功能类似,也是用来存储值,不同的是普通对象使用字符串作为属性名，而数组是**使**

**用数字来作为属性名**操作属性值,所以数组的存储性比普通对象要好，在开发中经常使用数组来存储数据

**注意:**因为是使用数组索引来操作属性,所以不能使用.的方法来控制,只能用[]的形式



**数组的值**

数组的值可以是任何的数据类型,不一定是数值,也可以是一个对象,甚至一个函数,还可以是一个其他数组

```js
var arr=[{name:"孙悟空",gender:"男",age:18}];

var arr2=[function(){arlert("1")};
arr2[0]();

var arr3=[[1,2,3],[1,2,3]]；//这个就是我们说的二维数组
```



### 7.1 创建数组

创建数组时有四种方式,其中前三种都是通过构造函数来创建数组,只是传入的参数不同

- 声明或创建一个不指定长度的数组

  ```js
  var arr=new Array();//这时创建的数组里面没有值,可以向里面加值
  ```

- 声明或创建一个指定长度的数组

  ```js
  var arr=new Array(10);//创建一个length长度为10的数组,没有默认值
  ```

- .声明或创建一个带有默认值的数组

  ```js
  var arr=new Array(10,20,50);//创建一个length长度为3,带有值10,20,50的数组
  ```

- 使用字面量创建数组(推荐使用这种方式)

  ```js
  var arr=[1,2,3,4,5,10];//创建一个length长度为5,默认值为1,2,3,4,5,10的数组
  //也可以创建不定长度的数组
  var arr2=[];
  
  //数组字面量和对象字面量的区别在于数组字母量是用[]括起来,并且不用写属性值,默认使用的索引作为属性值
  ```

  

**数组中读取与添加元素**

- **读取:数组[索引]**

  **注意:**如果读取不存在的索引,不会报错而是返回undefined,但是数组的长度还是原来有内容的长度

- **添加:数组[索引]=值**

  **注意:**

  - 如果给已经存在值的索引添加一个新值,旧值会被覆盖掉,数组长度不变

  - 如果给不存在值的索引添加一个新值,**数组的长度会变为添加新值的索引的值-1**,中间没有值的索引中会存

    入empty(空)



### 7.2 length

**length是数组的一个属性,代表数组的长度**

- 对于连续的数组,使用length可以获取到数组的长度(值的个数)

- 对于非连续的数组,使用length会获取到数组的最大的索引加1(没有值的索引为empty),尽量不要创建非连续的

  数组



**查看数组长度:**数组名.length

```js
var arr=[1,2,3];
console.log(arr.length);
```

**注意:数组的length属性是能修改的**

- **如果length大于原长度，则多余的部分索引的值为empty**
- **如果length小于原长度，则多出的元素会被删除，所以可以修改length的长度为0来让数组为空**



**向数组的最后一个位置添加元素**

**用法:数组名[数组名.length]=值**

```js
var arr=new Array()
arr[arr.length]=70；// 因为length永远是最大索引加1
```



### 7.3 数组的方法

**数组的方法一般都不会使原数组发生变化,而是返回一个新的数组,只有改变原数组结果的方法才会使得原数组发生**

#### 7.3.1 push与pop方法

- **push()方法可以向数组的末尾添加一个或多个值,并返回数组的新长度**

  - 添加一个值时,作用和用length向数组中最后添加一个值相同
  - 添加多个值时,参数用,隔开

  ```js
  var arr=[];
  //将要添加的值作为该方法的参数传递,添加的值会自动在数组的最后
  console.log(arr.push(1));//返回的值为1,返回值是这个数组的新长度
  console.log(arr);//值为1的数组
  
  console.log(arr.push(2,3));
  console.log(arr);//值为1,2,3的数组
  ```

- pop()方法可以删除数组的最后一个值，并将被删除的值作为返回值返回,不传入参数

  ```js
  var arr=[1,2,3];
  console.log(arr.pop());//返回3
  console.log(arr);//每使用一次数组长度length减少1
  ```

  

#### 7.3.2 unshift与shift方法

- **unshift()方法向数组开头添加一个或多个值,并返回新的数组长度**,添加多个值时,参数用,隔开。添加完成后其

  它值的索引一次向后调整对象的值

  **注意:**只能通过该方法在数组最前方添加新的值

  ```js
  var arr=[2,3];
  console.log(arr.unshift(1));//返回数组新长度3
  console.log(arr);//值为1,2,3的数组
  
  console.log(arr.unshift(-1,0));
  console.log(arr);//值为-1,0,1,2,3的数组
  ```

- shift()方法删除数组的第一个元素,并将被删除的元素作为返回值返回用法与pop()相反

  ```js
  var arr=[1,2,3];
  console.log(arr.shift());//返回1
  console.log(arr);//每使用一次数组长度length减少1,并且其他值的索引依次-1
  ```

  #### 7.3.1 push与pop方法

  - **push()方法可以向数组的末尾添加一个或多个值,并返回数组的新长度**

    - 添加一个值时,作用和用length向数组中最后添加一个值相同
    - 添加多个值时,参数用,隔开

    ```js
    var arr=[];
    //将要添加的值作为该方法的参数传递,添加的值会自动在数组的最后
    console.log(arr.push(1));//返回的值为1,返回值是这个数组的新长度
    console.log(arr);//值为1的数组
    
    console.log(arr.push(2,3));
    console.log(arr);//值为1,2,3的数组
    ```

  - pop()方法可以删除数组的最后一个值，并将被删除的值作为返回值返回,不传入参数

    ```js
    var arr=[1,2,3];
    console.log(arr.pop());//返回3
    console.log(arr);//每使用一次数组长度length减少1
    ```

    

  #### 7.3.2 unshift与shift方法

  - **unshift()方法向数组开头添加一个或多个值,并返回新的数组长度**,添加多个值时,参数用,隔开。添加完成后其

    它值的索引一次向后调整对象的值

    **注意:**只能通过该方法在数组最前方添加新的值

    ```js
    var arr=[2,3];
    console.log(arr.unshift(1));//返回数组新长度3
    console.log(arr);//值为1,2,3的数组
    
    console.log(arr.unshift(-1,0));
    console.log(arr);//值为-1,0,1,2,3的数组
    ```

  - shift()方法删除数组的第一个元素,并将被删除的元素作为返回值返回用法与pop()相反

    ```js
    var arr=[1,2,3];
    console.log(arr.shift());//返回1
    console.log(arr);//每使用一次数组长度length减少1,并且其他值的索引依次-1
    ```

    

####  7.3.3 forEach方法

**数组的遍历**

- for循环遍历数组,通过数组的length属性来获取数组的长度

  ```js
  var arr=[1,2,3,4,5];
  for(let i=0;i<arr.length;i++){
      console.log(i);
  }
  ```

- forEach()方法遍历数组(该方法只支持IE8以上的浏览器,如果要兼容IE8,用for循环)

  **forEach()方法需要一个函数作为参数才能使用,数组中有几个元素函数就会执行几次,不支持在函数中添加**

  **返回值**

  ```js
  var arr=[1,2,3];
  arr.forEach(function(){//这个函数只是我们创建,但是不需要我们调用,由浏览器自动调用,称为回调函数
  	console.log("hello");
  })
  ```

**每次执行时浏览器会将遍历到的数组以实参的形式传递进来,可以定义形参来读取这些内容**

**该方法有两个参数**

- 回调函数function(value,index,array)

  **浏览器在回调函数中传递了三个参数**

  - 第一个参数是遍历到的值value
  - 第二个参数是当前正在遍历元素的索引index

  - 第三个参数是正在遍历的数组(可选)


  ```js
  var arr=[1,2,3];
  arr.forEach(function(value,index,array){
      console.log(index+","+value);
      console.log(array);
  })
  ```

- 回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)



#### 7.3.4 map方法

**map(映射)()方法也是用做遍历数组,返回一个新数组,数组中的元素为原始数组元素调用函数处理后的值,并且按**

**照原始数组元素顺序依次处理元素**

**该方法有两个参数**

- 回调函数function(value,index,array){}(和forEach中的回调函数一样),但是可以在回调函数里加返回值

  **浏览器在回调函数中传递了三个参数**

  - 第一个参数是遍历到的值value
  - 第二个参数是当前正在遍历元素的索引index
  - 第三个参数是正在遍历的数组(可选)

- 回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)

```js
let arr = [12, 5, 8];
let result = arr.map(function (item) {
    return item*2;
})
let result2 = arr.map(item=>item*2);//map方法适合用箭头函数

console.log(result);//[ 24, 10, 16 ]
console.log(result2);//[ 24, 10, 16 ]

let score = [18, 86, 88, 24];
let result3 = score.map(item =>item>= 60?'及格':'不及格');
console.log(result3);//[ '不及格', '及格', '及格', '不及格']

let arr2=[1,2,3];
let result4=arr2.map(function(value,index,array),arr2){
    console.log(this);//this的指向为arr2
    return value+index;
}
```

####  7.3.5 reduce方法

**reduce(汇总)()方法接收一个函数作为累加器，数组中的每个值(从左到右)开始缩减,最终计算为一个值**

**该方法有两个参数**

- 回调函数function(total, value, index, array)

  **浏览器在回调函数中传递了四个参数**

  - 第一个参数是每次计算结束后的返回值(第一次计算时默认值是0)
  - 第二个参数是遍历到的值value
  - 第三个参数是当前正在遍历元素的索引index
  - 第四个参数是正在遍历的数组(可选)

- 回调函数的初始值initialValue(用于设置上方第一个参数第一次计算时的值)(可选)

```js
//数组求和
var arr=[1,2,3,4,5];
var result=arr.reduce(function(prev,next){
      return prev+next;
 })
console.log(result);//值为15;

//对象求和
var ps = [{'p':1,'num':1},{'p':2,'num':2},{'p':3,'num':3},{'p':4,'num':4}];
ps.reduce(function(prev,next){
      return prev+next.p*next.num;
},10)//回调函数的第一次调用时，第一个参数是10，第二个参数是p[0]

//检验数组中出现重复出现字符串的数目
var arr=["HTML","JS","CSS","JAVA","CSS","HTML","HTML"];
var result=arr.reduce(function(back,prop){
	back[prop]=back[prop]?++back[prop]:1;
    return back;
},{})
console.log(result);//{HTML: 3, JS: 1, CSS: 2, JAVA: 1}
```

#### 7.3.6 filter方法

**filter(过滤器)()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素**

**该方法有两个参数**

- 回调函数function(value,index,array)

  **浏览器在回调函数中传递了三个参数**

  - 第一个参数是遍历到的值value
  - 第二个参数是当前正在遍历元素的索引index
  - 第三个参数是正在遍历的数组(可选)

- 回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)

```js
//创建一个数组，判断数组中是否存在某个值
var newarr = [
  { num: 1, val: 'ceshi', flag: 'aa' },
  { num: 2, val: 'ceshi2', flag: 'aa2'  }
];
console.log(newarr.filter(item => item.num===2 ));

//去掉空数组空字符串、undefined、null
var arr = ['1',null,undefined, '3.jpg',''];
var newArr = arr.filter(item => item);//因为null,undefined和null转换为布尔值都是false
console.log(newArr);//只有1和3.jpg
```



#### 7.3.7 slice方法

**slice()方法可以用来从数组截取指定一部分值,这个方法不会影响原数组**

**该方法有两个参数**

- 截取开始的位置(必选)
- 截取结束的位置(查找时不包括结束位置)(可选),如果不写结束位置会从截取位置开始将后面所有值都截取

```js
var arr=[123,"孙悟空","猪八戒"]；
var result=arr.slice(0,2);
console.log(result);//值为123和孙悟空
```

**注意:**

- 该方法只能从左往右边截取,如果第一个数比第二个数大,则会返回空串
- 该方法接收负值,负值意味着从右往左数

 

#### 7.3.8 splice方法

**splice()方法可以用于删除数组中的指定元素，并向数组中添加新元素**,可以看作是push,pop和unshift,shift四种方

法的结合,**该方法会影响到原数组**,会将指定元素从元素组中删除,并将被删除的元素作为返回值返回

**注意:如果没有删除任何元素,返回空数组**

**该方法有任意多个参数,但是有两个必选参数**

- 第一个参数规定开始删除元素的索引位置
- 第二个参数规定应该删除的元素数量,值可以为0
- 第三个及以后的参数是要添加到数组中的新元素,这些元素将会自动插入到开始位置索引的前边

```js
var arr=[0,1,2,3,4];
var result=arr.splice(0，2);
console.log(arr);//值为2,3,4的数组
console.log(result);//值为0,1的数组
```

```js
//用作去除相等的数组中的数值时,可以用splice()方法来删除一个数组元素
//方法一
var arr=[1,2,3,5,3,3,6];
for(var i=0;i<arr.length-1;i++)
{
	for(var j=i+1;j<arr.length;j++)
	{
		if(arr[i]===arr[j])
		{
			arr.splice(j,1);
			j--;//当删除了当前的j所在元素以后,后面的元素会自动补位，此时将不会再比较这个元素，所以需
		}		//要自减才能比较		
	}
}
//方法二
var arr2=[1,2,3,5,3,3,6];
for(var i=arr2.length-1;i>=0;i--)//从后往前判断
{
	for(var j=i-1;j>=0;j--)
	{
		if(arr2[i]===arr2[j])
		{
			arr2.splice(j,1);
		}				
	}
}
//方法三(ES6方法去重)
var arr3=[1,2,3,5,3,3,6];
var arr4=[...new Set(arr3)];
/*
用new Set()会将传入的数组转换为Set结构数组,因为Set结构是不允许有重复的数据,所以会自动去重,最后通过	解构将Set结构数组重新转换为普通数组
*/
```

#### 7.3.9 concat方法

**concat()方法可以连接两个或多个数组,也可以连接单个的元素,并将新数组返回**,该方法不会对原数组产生影响

```js
var arr=[123,245];
var arr2=[566,156];

var result=arr.concat(arr2);//将两个数组连接起来
console.log(result);//result的值为123,245,566,156

//可以连接多个数组或值
var arr3=[1,2,3]
var result2=arr.concat(arr2,arr3,"999");
console.log(result2);//值为123,245,566,156,1,2,3,"999"
```

 **注意:**将一个数组放在另一个数组中最好的方法还是通过ES6的语法: ...数组名 来实现



#### 7.3.10 join方法

**join()方法可以将数组转换为一个字符串,并将转换后的字符串返回,**不会对原数组产生影响

**join中的参数为一个字符串,用这个字符串代替数组中的,(逗号)将数组分开**,默认值为,(逗号),与对整个数组使用

toString()方法效果一样

**注意:**如果在join()中传入了空串""作为参数,那么返回的字符串是整个数组合并后的值,相当于把数组中每个值用+连

接

```js
var arr=[1,2,3];
var str=arr.join();//默认用,分开
var str2=arr.join("");//空串将整个数组的值合并
var str3=arr.join("H");//用字符H隔开
console.log(str);//"1,2,3"
console.log(str2);//"123"
console.log(str3);//"1H2H3"
```



#### 7.3.11 reverse方法

**reverse()方法用作将数组里的值反转(左边的值到右边,右边的值到左边),该方法会直接修改原数组，返回值也是**

**修改后的数组**

```js
var arr=[1,2,3];
var result=arr.reverse();
console.log(arr);//值依次为3,2,1
console.log(result);//值依次为3,2,1
```

 

#### 7.3.12 sort方法

**sort()方法会对数组的元素进行排序,默认会按照Unicode编码进行排序(不是比较值的大小,即使对于纯数字的数**

**组,也会按照Unicode编码来排序),该方法会影响原数组**



**自己指定排序的规则**

**在sort()添加一个回调函数,回调函数中需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用回**

**调函数，使用哪个元素调用不确定，但是肯定的是在数组中a一定在b的前面,浏览器会根据回调函数的返回值来决**

**定元素的顺序**

**如果返回一个大于0的值 ，则元素会交换位置，如果返回一个小于0的值，则元素位置不变，如果返回0，则认为两个元素相等，也不交换位置**

```js
var arr=[5,4,2,1,3,8,9]

arr.sort(function(a,b){
	if(a>b){
		return 1
	}
	else if(a<b){
		return -1;
	}
	else
	{
		return 0;
	}
})
console.log(arr);//[1,2,3,4,5,8,9]
//上面是升序排列，如果要降序排列只用改变返回值

arr.sort(function(a,b){
    return a-b//上面写法的简写
})
```

#### 7.3.13 indexOf与lastIndexOf方法

- **indexOf()方法可以检索一个数组中是否含有指定的元素**,找到返回该元素在数组中的索引位置,没有找到则返

  回-1

  **该方法可以指定第二个参数,第二个参数是指定开始查找的位置(0是第一个位置)**

  ```js
  var arr=[1,2,3];
  var result=arr.indexOf(1);
  console.log(result);//0
  result=str.indexOf(1,1);
  console.log(result);//-1
  ```

- lastIndexOf()方法用法和IndexOf()类似,不同的是检索数组时是**从右到左**检索,也可以指定开始查找的位置

  **注意:**虽然是从右往左检索,但是在设置第二个参数的时候指定开始查找的位置还是从左往右数的,只是查找的时

  候是从右往左



#### 7.3.14 valueOf方法

**valueOf()返回数组原始值(数组本身)**

```js
var arr=[1,2,3];
var result=str.valueOf();
console.log(str===result);//true
```



#### 7.3.15 fill方法

**fill() 方法用于将一个固定值替换数组的元素**,该方法有三个参数,会改变原数组

**参数**

- value,表示填充的值(必填)
- start,表示开始填充的位置(选填)
- end,表示停止填充的位置(选填,默认是整个数组长度)

```js
var arr=new Array(100);//创建长度为100的数组
arr.fill(1);//将1填充到所有的空位置
/*上面相当于
for(var i=0;i<arr.length;i++){
    arr[i]=1;
}
*/
console.log(arr);//[1,1,1,1,1,1....1]
```



#### 7.3.16 find与findIndex方法

- **find()方法返回通过测试的数组的第一个元素的值，**接收一个回调函数,不会改变原始数组

  **浏览器在回调函数中传递了三个参数**

  - 第一个参数是遍历到的值value
  - 第二个参数是当前正在遍历元素的索引index
  - 第三个参数是正在遍历的数组(可选)

  **find() 方法为数组中的每个元素都调用一次函数执行**

  - 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数
  - 如果没有符合条件的元素返回 undefined

- **findIndex() 方法返回传入一个测试条件中符合条件的数组第一个元素位置**,用法同find()方法相同,接收一个回调函数,不会改变原始数组

  **findIndex()方法为数组中的每个元素都调用一次函数执行**

  - 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。
  - 如果没有符合条件的元素返回 -1

```js
var arr=[1,2,3,4];
var result1=arr.find(function(value,index,array){
    return value>2;
})
var result2=arr.findIndex(function(value,index,array){
    return value>2;
})
console.log(result1);//3
console.log(result2);//2
```



#### 7.3.17 some与every方法

- **some()方法用于检测数组中的元素是否满足指定条件,**接收一个回调函数, 不会改变原始数组

  **浏览器在回调函数中传递了三个参数**

  - 第一个参数是遍历到的值value
  - 第二个参数是当前正在遍历元素的索引index
  - 第三个参数是正在遍历的数组(可选)

  

  **some() 方法会依次执行数组的每个元素**

  - 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测

  - 如果没有满足条件的元素，则返回false

- **every() 方法用于检测数组所有元素是否都符合指定条件,**与some一样都接收一个回调函数,不改变原数组

  **every() 方法使用指定函数检测数组中的所有元素**

  - 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。
  - 如果所有元素都满足条件，则返回 true。

```js
var arr=[1,2,3,4];
var result1=arr.some(function(value,index,array){
    return value>2;
})
var result2=arr.every(function(value,index,array){
    return value>2;
})

console.log(result1);//true
console.log(result2);//fasle
```

#### 7.3.18 copyWithin方法

**coptWithin()方法用于在当前数组内部将指定位置的元素复制到其他位置,并且会覆盖掉原来的元素,**返回当前数组,**此方法会改变原数组,**该方法有三个参数

**参数:**

- target,从该位置替换数据
- start,从该位置读取数据,默认值是0,可以接受负值,负值代表从右往左数
- end.从该位置前停止读取数据,默认是整个数组长度,可以接受负值,负值代表从右往左数

```js
var arr=[1,2,3,4,5];
var result=arr.copyWith(0,3);//从数组第一个位置开始替换数据,从第四个位置开始读取,读取后面所有值
console.log(arr);//[4,5,3,4,5]
console.log(result);//[4,5,3,4,5]
```



#### 7.3.19 keys,values与entries方法

**这三个方法都用作遍历数组,都返回一个遍历器对象,可以用for...of语句进行遍历**

- keys()方法,对数组的键名(索引)进行遍历,返回一个新的数组
- values()方法,对数组的键值(值)进行遍历,返回一个新的数组
- entries()方法,对数组的键值对进行遍历,该方法会返回一个二维数组,会将遍历到的键名和键值装到一个数组里作为二维数组的值

```js
for(var index of [1,2].keys()){
    console.log(index);//0 1
}
for(var value of [1,2].values()){
    console.log(value);//1 2
}

for(var arr of[1,2].entries()){
    console.log(arr);//[0,1] [1,2]
}
for(var [index,value] of [1,2].entries()){
    console.log(index,value);//0,1 1,2
}
```



**Object的keys,values与entries方法**

Object的上述方法需要传入一个对象作为参数,此时会直接分别将键名,键值,键值对装在一个数组中

```js
var obj=["a":0,"b":1];
console.log(Object.keys(obj));//["a","b"]
console.log(Object.values(obj));//[0,1]
console.log(Object.entries(obj));//[["a",0],["b",1]]
```

#### 7.3.20ARRAY.FLat

数组降维

```
let a=[1,32,3,21,[32,321,3,21,[32,3,21,32]]]
a.flat(infinite)//当不知道数组为几维的时候，直接infinite，全部降维成1维。

```

#### 7.3.21flatMap

flatMap()方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。

```
let array=[[312312],[1,[2]],32,[2]];
let a=array.flatMap(item=>{
    return item*2
})
console.log(array)
console.log(a)

```

注意：flatMap()只能展开一层数组。

### 7.4 Array的方法

#### 7.4.1 Array.isArray方法	

**Array.isArray()方法检验一个对象是否为真数组(不支持低版本IE)**,可以用instanceof功能符来做兼容

```js
var arr=[];
if(arr instanceof Array){
    console.log("1");
}
if(Array.isArray(arr)){
	console.log("2");
}
```



#### 7.4.2 Array.from方法

**Array.from()方法用于将两类对象转换为真数组,**该方法有三个参数

**参数:**

- 一个用于转换为真数组的类数组对象
- 一个回调函数,类似于数组的map()方法中的回调函数,用来对每个元素进行处理,将处理后的值放入返回的数组
- 回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)

```js
//Nodelist对象
var div=document.getElementByTagName("div");
Array.from(div).forEach(function(value){
    console.log(value);
})

//arguments对象
function fun(){
    var arr=Array.from(argumens);
    console.log(arr);
}
```



#### 7.4.3 Array.of方法

**Array.of()方法用于将一组值转换为数组,**这个方法的主要目的是弥补构造函数Arrray()的因为参数数量的不同而造成行为不同的不足

```js
console.log(Array());//[]
console.log(Array(3));//[,,,]
console.log(Array(1,2,3));//[1,2,3]

console.log(Array.of(3));//[3]
console.log(Array.of(1,2,3));//[1,2,3]
console.log(Array.of(3).length);//1
```

## 8.字符串方法

## 9.函数对象

## 10.日期对象

## 11.Math对象

## 12.正则

## 13.异步,定时器

## 14.class

## 15.Class



## 16.Set

**ES6中提供了数据结构Set,该对象类似于数组,但是所有的值都是唯一的,在其中不会有重复的值,Set本身就是一个构造函数,用来生成Set类的实例对象**

**注意:**与数组和一般对象不同的是,Set实例没有属性名(键名),或者说属性名(键名)和属性值(键值)都是相同的值

### 16.1 用法

```js
var s=new Set();
[1,2,3,4,1,2].forEach(function(value){
    s.add(value);//Set类的对象只能通过add方法添加值
})
console.log(s);//Set(4){1,2,3,4}
```

```js
//在Set()中可以传入一个数组作为参数来作为Set实例的初始化对象
var s=new Set([1,2,3,4,1,2]);
/*该写法类似于
	[1,2,3,4,1,2].forEach(function(value){
    s.add(value);
})
*/

console.log(s);////Set(4){1,2,3,4}
console.log(s.size);//Set类有一个实例属性size来计算Set实例对象的长度
console.log([...s]);//[1,2,3,4]
/*
	上面的写法可以用作数组的去重
*/
```

**注意:**

- **在向Set实例中添加值的时候不会进行类型转换**,如:123与"123"不同
- **两个对象总是不同**
- **Set内部的判断两个值是否相同的算法结果类似全等运算符(===),不同在于在Set内部认为NaN与自身相等,所以也会去重**



### 16.2 属性与方法

#### 16.2.1 size

**Set类的实例有一个size属性,专门用来记录Set实例中的值的数量,返回Set实例成员的数量**



#### 16.2.2 add,delete,has与clear方法

- add()方法为Set实例添加一个值,返回实例对象本身,可以用作链式操作
- delete()方法删除Set实例的某个值,删除成功返回true,删除失败返回false
- has()方法判断Set实例中是否有某个值.有就返回true,没有返回false
- clear()方法情况Set实例中的所有值,没有返回值

```js
var s=new Set([1,2,3,4,5]);
s.add(6);
console.log(s);//Set(6){1,2,3,4,5,6}

s.delete(1);
console.log(s);//Set(5){2,3,4,5,6}

console.log(s.has(2));//true

s.clear();
console.log(s);//Set(0)
```



#### 16.2.3 keys,values与entries方法

keys()方法返回装有Set实例的键名的数组，values()方法返回装有Set实例的键名值的数组，entries()方法返回装有Set实例的键名和键值的数组,但是由于在Set实例中只有键值,所有三个方法返回的数组都是相同的,都只装有键值

```js
var s=new Set([1,2,3,4,5]);
console.log(s.keys());//[1,2,3,4,5]
console.log(s.values());//[1,2,3,4,5]
console.log(s.entries());//[1,2,3,4,5]
```



#### 16.2.4 forEach方法

**Set实例的forEach()方法的用法与表现结果与数组的forEach()方法的表现结果一致**,第一个参数是回调函数,第二个参数是回调函数中this的指向对象

```js
var s=new Set([1,2,3,4,5]);
s.forEach(function(value,index){
    console.log(index,value);//1,1 2,2 3,3 4,4 5,5 
})
```



### 16.3 WeakSet

WeakSet也是一个类,可以用new WeakSet()来创建一个WeakSet实例对象,该对象的结构和Set实例相似,但是还是有所区别

**区别:**

- **WeakSet的成员只能是对象,而不能是其他类型的值**
- **WeakSet实例中的成员对象都是弱引用,**即垃圾回收机制不会考虐WeakSet实例中对该对象的引用,如果其它对象没有引用该对象,垃圾回收机制会自动回收该对象所占的内存,不会考虐WeakSet实例中是否还保留着对该对象的引用,由于WeakSet实例的弱引用这个特性,所以ES6中有规定**WeakSet创建的实例不可被遍历**,因为WeakSet中的成员对象的引用随时会消失

```js
var w=new WeakSet([[1,2,3],{a:1,b:2,c:3}]);
console.log(w);
```

**方法**

WeakSet实例有add(),delete()和has()方法,用法同Set,但是没有遍历WeakSet实例本身的方法,因为该类实例没有size属性



## 17.Map

**ES6提供Map数据结构,该对象类似于普通对象,也是键值对的集合,但是该对象的键不像普通对象那样只能用字符串作为键,而是可以使用各种类型的值(包括对象)来作为键**

JS中的对象本质上是键值对的集合(Hash结构),但是传统上只能用字符串当作键,这就使得在使用JS对象的时候有很大的限制。也就是说，Object结构提供的是字符串与值相对应的键值对模式.而Map结构提供的是值与值相对应的键值对模式,相对来说更加的完善

### 17.1 用法

```js
var m=new Map();
var o={a:1};
m.set(o,1);
/*
只能通过set()方法来设置值，最好通过变量来储存键,以便于获取,因为如果不通过变量获取就不是对同一个对象的引
用,会返回undefiend
*/
console.log(m.get({a:1}));//undefined
console.log(m.get(o));//1
console.log(m.o);//undefined
console.log(m[o]);//undefined
/*
	只能通过get()方法来获取到对应键的内容,不能通过点或[]来获取,因为该结构不是普通对象的结构,通过这两种	  方式只能拿到普通对象键对应的值
*/
```

```js
//也可以传入普通的数据类型
var m=new Map([
    ["name","孙悟空"],
	[{age:18},18]
])
console.log(m.get("name"));//"孙悟空"
```

**注意:**

- 在直接通过结构赋值创建对象时,传入的参数需要是一个数组,同时数组中的每一个成员需要用一个二维数组括起来作为键值对
- 如果Map实例的键是一个简单类型的值,则只要两个值**严格相等**,Map内部就会将其视为一个值,比如0和-0依然是一个值,而1与"1"就不是一个值。NaN虽然不等于自身,但是Map内部将其视为同一个值



### 17.2 属性与方法

#### 17.2.1 size

**Map类的实例有一个size属性,专门用来记录Set实例中的值的数量,返会Map实例成员的数量**



#### 17.2.2 get,delete,has与clear方法

- get()方法为Map实例添加一个值,传入两个参数,分别代表键和值,返回实例对象本身,可以用作链式操作
- delete()方法删除Map实例的某个值,删除成功返回true,删除失败返回false
- has()方法判断Map实例中是否有某个值.有就返回true,没有返回false
- clear()方法情况Map实例中的所有值,没有返回值

```js
var m=new Map();
m.set("a",1);
m.set("b",2);

console.log(m);//Map(2) {"a" => 1, "b" => 2}
console.log(m.get("a"));//1

m.delete("a");
console.log(m.get("a"));//undefined

console.log(m.has("b"));//true

m.clear();
console.log(m);//Map(0){}
```



#### 17.2.3 keys,values与entries方法

keys()方法返回装有Map实例的键名的数组，values()方法返回装有Map实例的键名值的数组，entries()方法返回装有Map实例的键名和键值的数组,这些方法与Set实例不同,都能得到不同的数组



#### 17.2.4 forEach方法

**Map实例的forEach()方法的用法与表现结果与数组的forEach()方法的表现结果一致**,第一个参数是回调函数,第二个参数是回调函数中this的指向对象

```js
var m=new Map([["a",1],["b",2],["c",3]]);
m.forEach(function(value,key){
    console.log(key,value)//a 1 b 2 c 3
})
```

**注意:**Map遍历的顺序就是插入顺序,遍历行为基本与Set一致



### 17.3 类型转换

#### 17.3.1 与数组转换

- **Map转数组**

  ```js
  var m = new Map([["a", 1], ["b", 2], ["c", 3]]);
  console.log([...m]);//[Array(2), Array(2), Array(2)]
  /*
  	结果为数组中包含三个二维数组,每个二维数组分别存有一个Map对象的成员
  */
  ```

- **数组转Map**

  ```js
  var m=new Map([["a",1],["b",2],["c",3]]);
  console.log(m);//Map(3) {"a" => 1, "b" => 2, "c" => 3}
  ```

  

#### 17.3.2 与对象转换

- **Map转对象**

  **注:**只有Map实例中所有的键都是字符串才能转为对象

  ```js
  var m=new Map([["a",1],["b",2],["c",3]]);
  var obj={};
  for(var [key,value] of m){
      obj[key]=value;
  }
  console.log(obj);//{a: 1, b: 2, c: 3}
  ```

- **对象转Map**

  ```js
  var m=new Map();
  var obj={a:1,b:2,c:3};
  /*
  for(var key in obj){
      m.set(key,obj[k]);
  }
  由于for...in的性能原因,改用for...of
  
  */
  for(var key of Object.keys(obj)){
      m.set(key,obj[key]);
  }
  
  console.log(m);//Map(3) {"a" => 1, "b" => 2, "c" => 3}
  ```

  

#### 17.3.3 与JSON转换

- **Map转JSON**

  Map转为JSON时分两种情况,如果Map的简明全是字符串就转换为JSON对象,如果键名有非字符串,就转换为JSON数组

  - **Map=>JSON对象**

    ```js
    var m=new Map([["a",1],["b",2],["c",3]]);
    var obj={};
    for(var [key,value] of m){
        obj[key]=value;
    }
    var json=JSON.stringify(obj);//实质上时先转为对象再转为JSON
    console.log(json);
    ```

  - **Map=>JSON数组**

    ```js
    var m=new Map([["a",1],["b",2],[{c:3},3]]);
    var json=JSON.stringify([...m]);//还是先转换为数组在转换为JSON
    console.log(json);
    ```

    

- **JSON转Map**

  JSON转换为Map时,正常情况下所有的键名都会转为字符串，无论是不是对象,但是如果JSON整个是一个数组,且每一个数组成员本身都是一个二维数组,每个二维数组里面有两个成员,这样就能一一对应转换为Map。这往往是数组转为JSON的逆操作

  - **一般情况**

    ```js
    var json = '{"a":1,"b":2,"c":3}';
    var obj = JSON.parse(json);
    var m = new Map();
    for (var key of Object.keys(obj)) {
       m.set(key, obj[key]);
    }
    console.log(m);//Map(3) {"a" => 1, "b" => 2, "c" => 3}
    ```

  - **特殊情况**

    ```js
    var json='[[{"a":1},1],["b",2],["c",3]]';
    var m=new Map(JSON.parse(json));
    console.log(m);//Map(3) {{…} => 1, "b" => 2, "c" => 3}
    ```

    

### 17.4 WeakMap

WeakMap和Map的结果类似,也是一个类,也是用于生成键值对的集合,但是与Map依然有一些区别

**区别:**

- WeakMap实例只接收对象作为键名(null除外),不能使用其它类型的值作为键名使用
- WeakMap的键名指向的对象是弱引用,不会计入垃圾回收机制,同WeakSet一致

**注:**当我们想在某个对象上存储一些数据时,会形成对该对象的引用,从而让这个对象无法被回收,WeakMap就是为了解决这个问题而诞生的,它的键名都是弱引用,即垃圾回收机制不会将该对象的引用保留在内

```js
var div = document.getElementsByTagName("div");
var w = new WeakMap();
w.set(div, "这是div");
console.log(w.get(div)); //"这是div"

div = null;//清除引用对象
console.log(w.get(div)); //undefined
```

**方法**

WeakMap实例有get(),set(),has()和delete()方法,用法同Map,也无法被遍历,也无法被清空,所以没有size属性与clear()方法



**应用场景**

```js
var element=document.getElementById("element");
var w=new WeakMap();
w.set(element,{num:1});
element.onclick=function(){
    var data=w.get(element);
    data.num++;
};
/*
	element为一个DOM节点,每当发生点击事件的时候,就更新内部属性的值,但是确是将新值作为键值放在了		WeakMap中,键名为element,当element这个DOM节点被删除后WeakMap中的值会自动消失,没有了内存泄露的		风险
*/
```

## 18.Proxy

代理器,用于拦截不符合自定义要求的增删改查功能.Proxy可以理解为在目标对象之前设置一层拦截,外界对该对象的访问,都必须先通过这层拦截,因此提供了一种机制.可以对外界的访问进行过滤和改写。

```js
 let a={
            name:'dsads',
            age:32,
            hobby:'read'
        }
        // let proxy=new Proxy(a,{
        //     set(target,property,value){
        //         if(property=='name'){
        //             throw new TypeError('The age is not integer')
        //         }
        //         if(value>200){
        //             throw new RangeError('The age seems invalid')
        //         }
        //         target[property]=value
        //     }
        // })
        // proxy.age=222;
        // proxy.name='dasdsa'

        // proxy.age=11
        let target=function(){
            return 'i am the irror man'
        }
        let handler={
            apply(){
                return ' i am the proxy'
            }
        }
        let test= new Proxy(target,handler)
        test()
```

**注意:**

- 改变Proxy实例内对象的值的时候会自动执行内部的set()方法,也能够改变传入参数对象的值,但是如果通过原对象访问的属性只会返回对应对象的值,如果通过Proxy实例访问对象属性,则会执行内部的get()方法

  ```js
  var obj = { a: 1, b: 2, c: 3 };
  var p = new Proxy(obj, {
      get:function(target, key, receiver) {
          return “hello"
      },
      set:function(target,key,value,receiver){
  		Reflect.set(target, key, value, receiver);
  }
  });
  p.a=4;
  console.log(obj.a);//4
  console.log(p.a);//"hello"
  console.log(p.b);//"hello"
  console.log(p.c);//"hello"
  ```

- 如果Proxy构造函数的第二个参数是一个空对象,那么就没有任何拦截效果,访问proxy实例就等同于访问target

  ```js
  var obj = { a: 1, b: 2, c: 3 };
  var p = new Proxy(obj, {});
  p.a=4;
  console.log(obj.a);//4
  conosole.log(p.a);//4
  ```

  

**注:**Proxy实例还可以设置很多方法,设计模式中有一种代理模式完全可以通过这个实现

**Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与[proxy handlers](https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)的方法相同。`Reflect`不是一个函数对象，因此它是不可构造的。

## 19.reflect

### 描述

与大多数全局对象不同，`Reflect`不是一个构造函数。你不能将其与一个[new运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)一起使用，或者将`Reflect`对象作为一个函数来调用。`Reflect`的所有属性和方法都是静态的（就像[`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)对象）。

### 方法

`Reflect`对象提供以下静态函数，它们具有与[处理器对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)方法相同的名称。这些方法中的一些与 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 上的对应方法相同。

- [`Reflect.apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply)

  对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 [`Function.prototype.apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 功能类似。

- [`Reflect.construct()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)

  对构造函数进行 [`new` ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)操作，相当于执行 `new target(...args)`。

- [`Reflect.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty)

  和 [`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 类似。

- [`Reflect.deleteProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty)

  作为函数的[`delete`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete)操作符，相当于执行 `delete target[name]`。

- [`Reflect.enumerate()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/enumerate)

  该方法会返回一个包含有目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器，[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 操作遍历到的正是这些属性。

- [`Reflect.get()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get)

  获取对象身上某个属性的值，类似于 `target[name]。`

- [`Reflect.getOwnPropertyDescriptor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getOwnPropertyDescriptor)

  类似于 [`Object.getOwnPropertyDescriptor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)。

- [`Reflect.getPrototypeOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf)

  类似于 [`Object.getPrototypeOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)。

- [`Reflect.has()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has)

  判断一个对象是否存在某个属性，和 [`in` 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 的功能完全相同。

- [`Reflect.isExtensible()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/isExtensible)

  类似于 [`Object.isExtensible()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible).

- [`Reflect.ownKeys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)

  返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 [`Object.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys), 但不会受`enumerable影响`).

- [`Reflect.preventExtensions()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/preventExtensions)

  类似于 [`Object.preventExtensions()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)。返回一个[`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean)。

- [`Reflect.set()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set)

  将值分配给属性的函数。返回一个[`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean)，如果更新成功，则返回`true`。

- [`Reflect.setPrototypeOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf)

  类似于 [`Object.setPrototypeOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)。

### 示例

```js
const obj = {
  name: 'zce',
  age: 18
}

// console.log('name' in obj)
// console.log(delete obj['age'])
// console.log(Object.keys(obj))

console.log(Reflect.has(obj, 'name'))
console.log(Reflect.deleteProperty(obj, 'age'))
console.log(Reflect.ownKeys(obj))
```

## 20.Promise

Promise对象是对于JS中的异步操作的结果方案,可以说Promise是一个容器,在这里面保存了某个未来才会结束的事件(通常为一个异步操作)的结果

**Promise对象代表一个异步操作,有着三种状态:**

- pending,正在进行状态
- fulfilled,已成功状态
- rejected,已失败状态

**注意:**只有异步操作的结果可以决定当前是哪一种状态,任何其它的操作都无法改变该状态

### 20.1 优缺点

- **优点**

  Promise的状态不会受到外界的影响,并且一旦Promise的状态发生改变时,就不会再进行状态变化,任何时刻都可以得到这个状态结果

- **缺点**

  - 无法取消Promise,一旦新建就会立即执行,无法在中途取消
  - 如果不设置回调函数,Promise的内部机制会报错,不会反应到外部
  - 当处于pending正在执行的状态时,不能知道当前在哪一个阶段,不知道是否是开始还是结束



### 20.2 用法

Promise可以作为一个构造函数对象,传入的两个参数都是函数,第一个函数是代表成功,第二个代表失败,每个函数调用后都会在then()中找到自己对于的函数来执行

```js
var p=new Promise(function(success,rejected){
    setTimeout(function(){
        try{
            console.log(123);
            success(456);
        }catch{
            rejected("error");//在一次操作中之后进行success()函数和rejected()函数中的一个,执行
        }					//完毕后直接到下一个步骤
    },1000)
}).then(function(data){//执行success()后进入该函数
    console.log(data);//456
},function(err){//执行rejected()后进入该函数
    console.log(err);//error
})
/*
then()函数中的第一个回调函数中的参数就是在前一个异步操作中通过success()传的值,而第二个回调函数中的参
数是在前一个异步操作中rejected()传的值
*/
```

```js
//Promise正确的用法是实现链式操作来实现异步
var p=new Promise(function(success,rejected){
    console.log(123);
    success(456);
}).then(function(data){//假设现在只有成功才执行函数
    console.log(data);//456
    return 789;
    /*
    如果这里不写返回值,默认会返回undefined给下面then()中成功时的函数,注意的是这样写无论写什么普通的	数据类型都是成功的,都是为下面的then()函数传递了成功时的Promise
    */
}).then(function(data){
    console.log(data);//789
})
```

```js
//链式操作中失败的时候可以执行的异步操作
var p=new Promise(function(success,rejected){
    try{
    	console.log(123);
    	success(456);    
    }catch{
        rejected("error");
    }
}).then(
    function(data){
    
    console.log(data);//456
    return new Promise(function(success,rejected){
        	try{
            	success(789)
        	}catch{
        	    rejected("error");
        	}
    	});
},
    function(err){
    console.log(err);//error
	//失败就不会执行后面的then()了
}).then(
    function(data){
    console.log(data);//789
    return new Promise(function(success,rejected){
         	 rejected("error");//直接显示失败
      	});
	},
    function(err){
    console.log(err);//error
}).catch(
    function(err){
    	console.log(err);//error
	})
/*
可以在最后加上catch()代表着只有在失败时才会进行的方法,该方法可以看作是then()失败时的简写,因为then()
要写失败时的情况必须要传入两个参数，第二个才是失败时的参数函数,用catch()可以值捕获失败时的结果
*/
```



### 20.3 静态方法

#### 20.3.1 Promise.all()

**Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例**

```js
var p1=new Promise(function(){});
var p2=new Promise(function(){});
var p3=new Promise(function(){});
var p=Promise.all([p1,p2,p3]).then(function(data){
	console.log(data);
},function(err){
    console.log(err);
});
/*
	p内部的状态由p1,p2,p3决定,有两种情况:
	1.只有p1,p2,p3全部成功时p的状态才能使成功,p才能够执行后面成功的回调函数,此时data的值是由			  p1,p2,p3共同传入的值组成的数组
	2.只要p1,p2,p3中有一个失败,p的状态就会变成失败,p执行失败后的回调函数,此时err的值为首先完成异步并	   返回失败的Promise的返回值
*/
```

**注意:**

- Promise,all()中包含多个Promise实例的数组,只有这多个实例全部成功,或者至少有一个失败时才会调用后面then()中的回调函数
- **如果作为参数的Promise实例自己定义了catch()方法,那么该实例一旦失败不会触发Promise.all()后面定义的catch()方法,如果没有实例定义catch()方法,那么触发失败后会执行Promise.all()后面的catch()方法**	



#### 20.3.2 Promise.race()

**Promise.race()方法也用于将多个Promise实例包装成一个新的Promise实例**

```js
var p1=new Promise(function(){});
var p2=new Promise(function(){});
var p3=new Promise(function(){});
var p=Promise.all([p1,p2,p3]).then(function(data){
	console.log(data);
},function(err){
    console.log(err);
});
/*
	p内部的状态由p1,p2,p3其中一个决定,只有其中有一个先完成异步操作,p的状态就会跟着发生改变,如果先发生	   成功则执行第一个回调函数,如果先发生失败则执行第二个回调函数
*/
```



#### 20.3.3 Promise.resolve()

**Promise.resolve()方法用于将现有的对象转换为Promise对象,并且该对象中的值就是成功时的函数传入的参数**

```js
var p=Promise.resolve(123);
//等价于
var p=new Promise(success,rejected){
    success(123);
}
```

**该方法的参数有多种情况**

- **参数为一个Promise实例**

  不作任何改变,直接返回这个Promise实例

- **参数为一个具有then()方法的thenable对象**

  Prommise.resolve()方法会将这个对象转换为Promise对象,然后立即执行里面的then()方法

  ```js
  var thenable={
      then:function(success,rejected){
          console.log(123);//123
          success(456)
      }
  };
  var p = Promise.resolve(thenable).then(function(data) {
          console.log(data);//456
  });
  /*
  	上面的代码会在控制台上打印出来
  */
  ```

- **参数为一个普通值类型的或者不是thenable对象时**

  会直接将传入的参数作为成功时的参数传入到then()的成功函数的参数中

- **没有参数**

  直接得到一个成功时不传入参数的Promise对象



#### 20.3.4 Promise.reject()

**Promise.reject()方法也用于将现有的对象转换为Promise对象,并且该对象中的值就是失败时的函数传入的参数**

**注意:**Promise.reject()方法中传入的参数会原封不动的作为失败时的错误理由,不会发生参数的改变,和Promise.resolve()方法有区别

```js
var p=Promise.reject("error");
//等同于
var p=new Promise(function(success,rejected){
	rejected("error");
})
```



## 21.Iterator

**Iterator(迭代器)是一种接口,或者说是一种机制。它能为各种不同的数据结构提供统一的访问机制,任何数据结构只要部署Iterator接口,就可以完成遍历操作(即依次处理该数据结构的所有成员)**

**作用**

- 为各种数据结构，提供一个统一的、简便的访问接口
- 使得数据结构的成员能够按某种次序排列
- 供for...of语句使用



**Iterator本质上是一个指针对象**

**指针实现过程**

1. **创建一个指针对象，指向当前数据结构的起始位置**
2. **第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员**
3. **第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员**
4. **不断调用指针对象的`next`方法，直到它指向数据结构的结束位置**



**一些数据结构原生就具有Iterator接口,如果没有就必须设置Iterator接口才能使用**

- **普通函数实现Iterator**

  ```js
  function myIter(obj){
    var i = 0;
    return {
      next(){
        var done = (i>=obj.length);
        var value = !done ? obj[i++] : undefined;
        return {
          value,
          done,
        }
      }
    }
  }
  ```

- **具有Iterator接口的原生数据结构**

  - Array
  - Map
  - Set
  - String
  - 函数的 arguments 对象
  - NodeList 对象

  ```js
  //数组的Symbol.iterator方法
  var arr = ['a', 'b', 'c'];
  var iter = arr[Symbol.iterator]();
  //通过next()方法实现每一次的迭代器的遍历
  iter.next() // { value: 'a', done: false }
  iter.next() // { value: 'b', done: false }
  iter.next() // { value: 'c', done: false }
  iter.next() // { value: undefined, done: true }
  /*
  	value是每次遍历到的值,done代表是否将该数组遍历完全
  */
  ```

- **类数组调用数组的Symbol.iterator方法**

  ```js
  var iterable = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
  };
  //for...of语句实际上就是对数组使用next()方法直到将数组遍历完全
  for (let item of iterable) {
    console.log(item); // 'a', 'b', 'c'
  }
  ```

  **注意:**

  - 普通对象部署数组的Symbol.iterator方法没有任何效果,必须是要属性值为数值,迭代器内部实际上是通过属性名的自增来实现迭代的

    ```js
    var iterable = {
      a: 'a',
      b: 'b',
      c: 'c',
      length: 3,
      [Symbol.iterator]: Array.prototype[Symbol.iterator]
    };
    for (let item of iterable) {
      console.log(item); // undefined, undefined, undefined
    }
    ```

  - 字符串虽然是一个类数组的对象，也具有Iterator原生接口

    ```js
    var someString = "hi";
    typeof someString[Symbol.iterator]
    // "function"
    
    var iterator = someString[Symbol.iterator]();
    
    iterator.next()  // { value: "h", done: false }
    iterator.next()  // { value: "i", done: false }
    iterator.next()  // { value: undefined, done: true }
    ```



## 22.Generator

**Generator函数是ES6提供的一种异步编程解决方案.,语法行为与传统的普通函数完全不同。**执行Generator函数会返回一个遍历器对象。也就是说,Generator函数还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态

**Generator函数跟普通函数的区别**

- function关键字与函数名之间有一个星号
- 函数体内部使用yield表达式，定义不同的内部状态
- Generator函数不能使用new关键字,否则会报错

### 22.1 用法

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
console.log(hw);
/*
	上面是一个Generator函数调用后该函数并不会运行,也不会返回函数的运行结果,而是返回的是一个遍历器对	 象,内部的yield表达式为一个个阶段,所以该函数一共有三个阶段状态:hello,world,与retrun语句结束执行	 状态
*/
console.log(hw.next());//{value: "hello", done: false}
console.log(hw.next());//{value: "world", done: false}
console.log(hw.next());//{value: "ending", done: true}
console.log(hw.next());//{value: undefined, done: true}
/*
	如果想要运行函数内部的每一个函数,就必须要调用next()方法,使得指向函数的指针移向下一个状态,每次调用	 next()方法时,内部指针就会从函数头部或上一层停下来的地方开始执行,直到运到下一个yiedl表达式或遇到		return语句(注意遇到return语句函数会直接停止),在停止后依然能调用next()方法,但是此时的返回值为		undefined
*/
```

**总之,Generator函数是分段执行的,yield表达式是暂停执行的标记,而next()方法可以恢复执行**



**Genterator函数的写法**

ES6并没有规定function关键字与函数名之间的星号应该写在哪个位置,所以可以用多种方法书写

```js
function * gen(x, y){}
function *gen(x, y){}
function* gen(x, y){}///推荐使用这种形式声明Genterator函数
function*gen(x, y){}
```



**作为对象方法的Generator函数写法**

```js
let obj = {
  * gen() {
  }
};
```



**与 Iterator 接口的关系** 

**由于Generator函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口**

```js
Object.prototype[Symbol.iterator] = function* (){
  for(let i in this){
    yield this[i];
  }
}

function* iterEntries(obj) {
  let keys = Object.keys(obj);
  for (let i=0; i < keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}

let myObj = { gen: 3, bar: 7 };

for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}
```

## 



### 22.2 yield

**由于Generator函数返回的遍历器对象,只有调用next()方法才会遍历下一个内部状态,所以提供了一种可以暂停执行的函数,yield表达式就是暂停标志**

**注意：**

- yield表达式只能用在Generator函数里面，用在其他地方都会报错。

- 将yield表达式用在另一个表达式之中，必须放在圆括号里面。

```js
console.log('Hello' + (yield 123));
//通过此种形式调用yield表达式,但是此时作为值的并不是123,而是下一次next()中传入的参数
```

### 

**调用next()方法的运用逻辑**

1. 遇到yield表达式，就暂停执行后面的操作，并**将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值**
2. 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式
3. **如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将`return`语句后面的表达式的值，作为返回的对象的value属性值**
4. 如果该函数没有return语句，则返回的对象的value属性值为undefined



**yield与renturn的异同**

- **相同点**

  都能返回紧跟在语句后面的那个表达式的value属性值

- **不同点**

  每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次return语句，但是可以执行多次yield表达式。正常函数只能返回一个值，因为只能执行一次return,而Generator 函数可以返回一系列的值，因为可以有任意多个yield



### 22.3 Generator的方法

#### 22.3.1 next方法的参数

**yield表达式本身没有返回值，或者说总是返回undefined。next()方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值(注意这里的返回值是在外部返回给函数内部的)**

```js
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { 
        i = -1; 
    }
  }
}

var g = f();

g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }
```

**Generator函数从暂停状态到恢复运行，它的上下文状态是不变的。通过next方法的参数，就可以在Generator函数开始运行之后，继续向函数体内部注入值**

```js
function* gen(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = gen(5);
console.log(a.next()); // Object{value:6, done:false}
console.log(a.next()); // Object{value:NaN, done:false}
console.log(a.next()); // Object{value:NaN, done:true}

var b = geno(5);
console.log(b.next()); // { value:6, done:false }
console.log(b.next(12));  // { value:8, done:false }
console.log(b.next(13));  // { value:42, done:true }
```



#### 22.3.2 return方法

**Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且立刻结束遍历Generator函数**

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

console.log(g.next());// { value: 1, done: false }
console.log(g.return('foo'))// { value: "foo", done: true }
console.log(g.next());// { value: undefined, done: true }
```

## 

### 22.4 for...of循环

**for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法**

```js
function *gen() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of gen()) {
  console.log(v);
}
// 1 2 3 4 5
```

```js
function* gen() {
  let [prev, curr] = [1, 1];
  while(true){
    [prev, curr] = [curr, prev + curr];
    yield curr;
  }
}

for (let n of gen()) {
  if (n > 10000000) break;
  console.log(n);
}

```



### 22.5 yield* 

**如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。这个时候需要用到yield*表达式来在一个Generator函数内部执行另外一个Generator函数**

```js
function* gen() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  gen();
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// "x"
// "y"
//中间的gen()函数并没有被执行
```

```js
function* gen() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  yield* gen();
  yield 'y';
}

//等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

//等同于
function* bar() {
  yield 'x';
  for (let v of gen()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// "x"
// "a"
// "b"
// "y"
```



## 23.async

为了使得异步操作更加的简便,ES8标准引入了async函数,async函数是Generator函数的语法糖,基本是模仿Generator函数并作出了一些改变

**async与Generator的区别**

- 有了内置执行器,Generator函数的执行必须靠执行器,而async函数自带执行器。也就是说,**async函数的执行，与普通函数一样,只要一行就能执行所以过程**
- async的语义比Generator的语义更加的清楚,**命名与使用async函数需要用到asyuc和await关键字,**相对于Generator函数的*和yield更加让人理解,async表示函数内部有异步操作,而await表示在await后面的表达式需要等待结果
- yeild后面可以是任何数据类型,而正常情况下,**await后面是一个Promise对象,如果并没有手动设置一个Promise对象,而后面的表达式会被转成一个立即成功(await后面上面都不写也会传undefined)的Promise对象**
- **async后的所有能返回值的结果都是Promise**

**所以,async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await就是内部then()方法的语法糖**



**async与Generator函数的应用对比**

- Generator

```js
var fn = function (time) {
  console.log("开始处理异步");
  setTimeout(function () {
    console.log(time);
    console.log("异步处理完成");
    iter.next();
  }, time);

};

function* g(){
  console.log("start");
  yield fn(3000)
  yield fn(500)
  yield fn(1000)
  console.log("end");
}

let iter = g();
iter.next();
```

- async

```js
var fn = function (time) {
  return new Promise(function (resolve, reject) {
    console.log("开始处理异步");
    setTimeout(function () {
      resolve();
      console.log(time);
      console.log("异步处理完成");
    }, time);
  })
};

var start = async function () {
  // 在这里使用起来就像同步代码那样直观
  console.log('start');
  await fn(3000);
  await fn(500);
  await fn(1000);
  console.log('end');
};

start();
```



**注意:**

**如果await后面的异步操作出错，那么等同于async函数返回的Promise对象直接失败,并且会将错误对象作为参数传递给then()方法的第二个函数或者catch()方法回调函数中**

```js
async function f() {
  await new Promise(function (success, rejected) {
    throw new Error('error');
  });
}

f().then(function(value){
    console.log(value)
}).catch(function(err){
    console.log(err)//Error:error
});
```

```js
//用try...catch来捕捉
  async function f() {
      try {
          await new Promise(function(success, rejected) {
              throw new Error("error");
          });
      } catch (err) {
          console.log(err);
      }
      return await "hello world";
  }
f().then(function(data) {
    console.log(data);
});
```

```js
//如果有多个await命令，可以统一放在try...catch结构中。
async function main() {
  try {
    var val1 = await firstStep();
    var val2 = await secondStep(val1);
    var val3 = await thirdStep(val1, val2);

    console.log('Final: ', val3);
  }
  catch (err) {
    console.error(err);
  }
}
```

## 24.Module

模块功能主要由两个命令构成

- **export命令用于规定模块的对外接口**
- **import命令用于输入其他模块提供的功能**

# FLOW.js

## 1.简介

JS作为一种脚本语言是没有类型检测的，这个特点有时候用着很爽，但当你在一个较大的项目中的时候，就会发现这其实是一件挺糟糕的事情，因为和你协作的程序员往往不太清楚你所写的代码到底哪种类型才是正确的，而且代码重构的时候也很麻烦。于是基于这个需求有了Typescript和Flow的产生

Flow.js是FaceBook发布的开源Javascript静态类型检查器。他给JavaScript提供了静态类型来提高开发人员的生产力和代码质量。

## 2.优点

- 类型检测
- 只能提示更加完善，因为js很多时候编辑器不知道你的类型，就无法提供正常的提示
- 快速重构
- 类型注解，方便开发人员理解项目代码

- 较之typescript使用学习成本更低，因为flow只是一个辅助工具

## 3.安装

- 初始化项目            yarn init -y
- 安装flow 模块        yarn add flow-bin --dev
- 初始化flow             yarn flow init
- 启动flow                 yarn flow

## 4.使用

 在需要类型检测的文件第一行加入 *// @flow*

### 4.1 类型推断

即使没有编写类型注释的情况下flow依旧可以根据我们进行的一些运算智能的推断，不过不建议这么做，类型看起来不够明确。

![image-20200523161410235](C:\Users\94827\AppData\Roaming\Typora\typora-user-images\image-20200523161410235.png)

### 4.2 类型标注

#### 4.2.1 原始类型标注

```js
const a: string = 'zhihu'; 
const b: number = 5; 
const c: boolean = false; 
const d: void = undefined; 
const e: null = null;
```

以上需要注意的几点：

- 类型标注都是小写的
- null的类型是null
- undefined的类型是void

#### 4.2.2函数标注

函数标注表示返回结果的数据类型

```js
// 函数声明 
function foo () :number {
    return '100' //string [1] is incompatible with  number [2]
}
function bar () :void{

}
// 函数表达式
const foo=function() :string{
    return 100  //number [1] is incompatible with  string [2]
}
// 箭头函数
foo=() :null=>{
    return 'a'   //string [1] is incompatible with  null [2]
}
```

#### 4.3 数组类型

- *Array 后接一对尖括号，且尖括号里边就是数组项的类型名称；*，对于jsx不友好，会被错误解析

  const arr1:Array<number>=[12,23,3]

- 类型名称后加一对中括号。

  const arr2:number[]=[1,23,2]

#### 4.4 对象类型

- 变量名后跟对象形式的类型注解即可对对象进行类型注解，个数和下标需要一一对应

  ```js
  const obj:{foo:string,bar:number}={foo:'sss',bar:12}
  ```

- 在初始定义时不确定属性是否需要定义的时候可以在key后加？表示可选。

  ```js
  const obj2:{foo?:string,bar:number}={bar:1}  //?表示可选
  ```

- 更优雅的方式是用type 去写，会很清晰

  ```js
  type obj3Type={
      foo:string,
      bar:number
  }
  //type 是 Flow 中的关键字，用来定义自定义的类型
  const obj3:obj3Type={foo:'312',bar :12}
  ```

- 初始定义未定义但后续添加又需要类型检测时，可以用类似索引器的写法

  ```js
  //需要动态添加的可以，用这种类似索引器的语法
  const obj4: { [string]: string } = {}
  obj4.key=1312
  
  ```

#### 4.5 字面量类型注解

```js
const a:'foo'='foo'//通过
const a:'111'='foo'//Cannot assign `'foo'` to `a` because  string [1] is incompatible with  string literal `111` 
```

#### 4.6 或类型注释

```js
type bType=string|1232|[]
const b :bType ='foo'
```

#### 4.7 Maybe 类型

```js
// 相当于
// const gender: number | null | void = undefined
const gender:?string=undefined;
```

注意：

- 4.5 字面量类型必须严格相等
- 4.6或不是||而是|

#### 4.8 mixed混合类型

可以理解为6大数据类型都可以，但是在这还是强类型的，第一次明确变量类型的时候就被检测到了，后续再检测到其他类型就会报错。

```js
// string | number | boolean | ....
function passMixed(value: mixed) {
     // value.substr(1)

    // value * value //报错
    if (typeof value === 'string') {
        value.substr(1)
    }

    if (typeof value === 'number') {
        value * value
    }
}

passMixed('string')

passMixed(100)
```

#### 4.9 any任意数据类型

任意数据类型都可以，且是动态的，主要是用来兼容项目里的不知道数据类型时候的代码。

```js
function passAny(value: any) {
    value.substr(1)

    value * value
}

passAny('string')

passAny(100)
```



## 5.输出

### 5.1 flow自带的移除类型检测模块

- 安装

```cmd
yarn add flow-remove-types 
```

- 使用 

```
yarn flow-remove-types  . -d dist       //将所有js文件输出到dist文件夹下
yarn flow-remove-types src -d dist      //将所有src目录下的js文件输出到dist文件夹下
```

### 5.2 使用babel

- 安装

```
yarn add @babel/core @babel/cli @babel/perset-flow
//碰到安装失败一定要找到错误的模块，然后remove再安装
```

- touch .babelrc文件 ，输入

```
{
	"presets": ["@babel/preset-flow"]
  }
  
```

- 使用

  ```
  yarn babel src -d dist
  ```

## 推荐插件

flow-language   //编译阶段就可以进行检测

```

```



# TYPESCRIPT

## 1.简介

TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，TypeScript 在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。

其实TypeScript就是相当于JavaScript的增强版，但是最后运行时还要编译成JavaScript。TypeScript最大的目的是让程序员更具创造性，提高生产力，它将极大增强JavaScript编写应用的开发和调试环节，让JavaScript能够方便用于编写大型应用和进行多人协作。

## 2.与js的对比

- TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）
- TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。
- TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。
- TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义，所以对于我们前端从业者来说，学习前来得心应手，并没有太大的难度。
- TypeScript可以重用JavaScript代码，调用流行的JavaScript库。
- TypeScript提供了类、模块和接口，更易于构建组件和维护。
- **typescript可以支持最新的es标准且可以配置输出成es6或者以下的版本。**

## 3.安装

- 初始化项目 

  ```
  yarn init -y
  ```

- 安装typescript

  ```
  yarn add typescript --dev  //碰到卡顿的情况，切换npm
  ```

- 初始化ts配置文件

  ```
  yarn tsc --init
  ```

## 4.使用

### 4.1 原始数据类型

​	和flow.js基本一致

```ts
const a:string='hello'
const b:number=12
const c:object={Typescript:'word'}
const d:null=null;
const e:undefined=undefined;
//如果这边出现报错，就说明tsconfig.json中的target为es6以下版本
// 因为Symbol是es6中添加的数据类型
// 使用它的前提是必须确保有对应的 ES2015 标准库引用
// 也就是 tsconfig.json 中的 lib 选项必须包含 ES2015
const f: symbol = Symbol();
const g:boolean=true
// 表示没有任何返回值的函数：
function alert():void{
    console.log(312)
    // return 123
}
// 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：
let unusable: void = undefined;
```

### 4.2 作用域问题

```ts
作用域问题

默认文件中的成员会作为全局成员
多个文件中有相同成员就会出现冲突
const a = 123

解决办法1: IIFE 提供独立作用域
(function () {
  const a = 123
})()

解决办法2: 在当前文件使用 export，也就是把当前文件变成一个模块
模块有单独的作用域
// const a:number=1 //'a' was also declared here.
const a=123
export {}
```

### 4.3 对象类型

在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。

#### 什么是接口

在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。

TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象]()以外，也常用于对「对象的形状（Shape）」进行描述。

```ts
export {}

const foo:object=function(){}

const obj:{foo:number}={foo:123}

interface Person{//接口

  num:number;

  name:string;

}

const obj :Person={

  num:132,

  name:'312'

}
```

​	接口生命的数据类型，不仅类型需要匹配上，数量、key也需要匹配上

```ts
interface  Person{
    num:number;
    name:string;
    gender:boolean //    'gender' is declared here.
}
const obj :Person={
    num:132,
    name:'312'
}
//Property 'gender' is missing in type '{ num: number; name: string; }' but required in type 'Person'.
```

4.4 数组类型

```ts
export {} // 确保跟其它示例没有成员冲突

// 数组类型的两种表示方式

const arr1: Array<number> = [1, 2, 3]

const arr2: number[] = [1, 2, 3]
//传入的所有参数都必须是number
function sum(...args:number[]){
    console.log(args)
}
sum (1,23,2)
```

### 4.4 元组

数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。

元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。

```ts
export { }
const tuple: [string, number] = ['312321', 232]
const entries: [string, number][] = Object.entries({
    foo: 23,
    bar: 400
})
const [ke,value ]=entries;
```

### 4.5 枚举

枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。

- *数字枚举，枚举值自动基于前一个值自增*

  ```
  // enum PostStatus {
  //   Draft = 6,
  //   Unpublished, // => 7
  //   Published // => 8
  // }
  ```

- 字符串枚举



### 4.6 函数类型

```ts
export {} // 确保跟其它示例没有成员冲突

function func1 (a: number, b: number = 10, ...rest: number[]): string {
  return 'func1'
}

func1(100, 200)

func1(100)

func1(100, 200, 300)

// -----------------------------------------

const func2: (a: number, b: number) => string = function (a: number, b: number): string {
  return 'func2'
}
```



### 4.7 any

```ts
// 任意类型（弱类型）

export {} // 确保跟其它示例没有成员冲突

function stringify (value: any) {
  return JSON.stringify(value)
}

stringify('string')

stringify(100)

stringify(true)

let foo: any = 'string'

foo = 100

foo.bar()

// any 类型是不安全的
```

### 4.8 断言

​	<>res断言和res*res

```
// 类型断言

export {} // 确保跟其它示例没有成员冲突

// 假定这个 nums 来自一个明确的接口
const nums = [110, 120, 119, 112]

const res = nums.find(i => i > 0)

// const square = res * res

const num1 = res as number

const num2 = <number>res // JSX 下不能使用
```

### 4.9 枚举

```ts
export { } // 确保跟其它示例没有成员冲突
interface Post {
    title: string
    content: string
    subtitle?: string
    readonly summary: string
}
const hello: Post = {
    title: 'Hello TypeScript',
    content: 'A javascript superset',
    summary: 'A javascript'
}
interface Cache {
    [prop: string]: string
}

const cache: Cache = {}

cache.foo = 'value1'
cache.bar = 'value2'
```

### 4.10 class



```
export {} // 确保跟其它示例没有成员冲突

class Person {
    name: string
    age: number
    constructor(name: string, age: number) {
        this.age = age;
        this.name = name
    }
    

}
```

- 访问修饰符

TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 `public`、`private` 和 `protected`。

- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
- `private` 修饰的属性或方法是私有的，不能在声明它的类的外部访问
- `protected` 修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的

```ts
export { }
class Person {
    public name: string
    private age: number
    protected gender: boolean

    constructor (name:string,age:number){
        this.name = name
        this.age = age
        this.gender = true
    }

}
console.log(Person.name)
console.log(Person.age)
console.log(Person.gender)
```

### 4.11 readonly

只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。



```
class Animal {    readonly name;    public constructor(name) {        this.name = name;    }}
let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';
// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property.
```

注意如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面。



```
class Animal {
    // public readonly name;
    public constructor(public readonly name) {
        // this.name = name;
    }
}
```

4.12 类与接口

实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 `implements` 关键字来实现。这个特性大大提高了面向对象的灵活性。

```ts
export{}

interface Eat{
    eat(food:string):void
}

interface Run{
    run(distance: number) :void
}


class Person implements Eat, Run {
    eat(food: string): void {
        console.log(`优雅的进餐: ${food}`)
    }

    run(distance: number) {
        console.log(`直立行走: ${distance}`)
    }
}

class Animal implements Eat, Run {
    eat(food: string): void {
        console.log(`呼噜呼噜的吃: ${food}`)
    }

    run(distance: number) {
        console.log(`爬行: ${distance}`)
    }
}

```

### 4.12 抽象类

`abstract` 用于定义抽象类和其中的抽象方法。

- 抽象类是不允许被实例化的：
- 抽象类中的抽象方法必须被子类实现：

```ts
export{}
abstract class An{
    eat(food:string) :void{
        console.log(`呼噜呼噜的吃: ${food}`)
    }
    abstract run (distance:number):void
}

class Dog extends An{
    run(distance: number): void {
        console.log(distance)
    }

}
const d=new Dog
d.eat('321')
d.run(31231)
```

### 4.13 泛型

与泛型接口类似，泛型也可以用于类的类型定义中：

```ts
function createArray(length:number,value:number):number[]{
    const array=Array<number>(length).fill(value)
    return array
}

function createObjArray(length:number,value:object):object[]{
    const array=Array<object>(length).fill(value)
    return array
}

//上面两种函数都是实现填充数组但是因为数据类型不同的原因写了，很冗余，
// 于是就可以用到泛型了/
function create<T> (length:number ,value :T):T[]{
    const array=Array<T>(length).fill(value)
    return array
}
const res=create(1,23)
```

### 4.14 类型申明模块

在实际开发中，很多时候我们会去引入npm包，现在很多生态都还没支持ts，也就是类型检测。在引入的时候ts会报错，没有检测到类型申明。这个时候如果ts社区已经有了相应的生态，则错误提示会有建议下载的包，npm 添加使用即可，如果没有的话，就需要自己进行类型申明。

```ts
import { camelCase} from 'lodash'


declare function camelCase(input:string):string;


camelCase('111')
```

## 5.输出

```
yarn  tsc ./01-getting-start.ts //输出某一ts文件，该情况无法使用tsconfig.json的配置
yarn tsc  //输出整个目录内的ts文件
```

















































































# 初始化一个webpack工程

- 新建一个自定义文件夹，并创建子文件夹src、及src内的index.js

- 初始化项目 npm init 或者 npm init -y  

- ```
  mkdir webpack-demo
  cd webpack-demo
  npm init -y
  npm i --save-dev webpack webpack-cli
  -------------
  mkdir src && cd src && touch index.js
  ```

- 看到目录内存在packge.json文件就说明初始化成功

- 此时配置devServer

- npm i --save-dev webpack-dev-server

- 在src同级目录创建webpack.config.js

- 引入html模板

- npm i --save-dev html-webpack-plugin

- 在webpack.config.js中输入

- ```js
  const HtmlWebpackPlugin = require('html-webpack-plugin')
  module.exports = {
    mode: 'none',
    stats: 'none',
    devtool: 'source-map',
    plugins: [
      new HtmlWebpackPlugin()
    ]
  }
  
  ```

- npm webpack-dev-server ./src/index.js --open

